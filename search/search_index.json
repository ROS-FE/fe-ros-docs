{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"FE ROS by Robolab","text":"<p>The Laboratory of Robotics (RoboLab, https://www.robolab.si/) organizes a workshop dedicated to learning the basics of the Robot Operating System - ROS. The workshop is heavily focused on practical knowledge and exercises. The page you're seeing was created to be an aid to the in-person workshop. Here you will find explanations, outside sources, code snippets and more.</p> <p>This documentation website was created by the presenters and organizers of the workshop.</p>"},{"location":"#content","title":"Content","text":"<p>This workshop will cover the following topics:</p> <ul> <li>Introduction to ROS</li> <li>Transformation and trajectory planning</li> <li>Visualization &amp; Simulation</li> <li>Practical work with robots</li> </ul>"},{"location":"DAY0/","title":"DAY 0","text":"<p>test index sekcija.</p>"},{"location":"DAY0/page-1/","title":"Page 1","text":""},{"location":"DAY0/page-1/#sect-1","title":"sect 1","text":"<p>test.</p>"},{"location":"DAY0/page-2/","title":"Page 2","text":""},{"location":"DAY0/page-2/#sect-2","title":"sect 2","text":"<p>test.</p>"},{"location":"about/","title":"About","text":"<p>This workshop is organized by the Laboratory of Robotics at the Faculty of Electrical Engineering, University of Ljubljana.</p>"},{"location":"additional/","title":"Additional knowledge","text":""},{"location":"additional/#navodila-za-namestitev-ubuntu-1804-server-ros-melodic-na-raspberrypi-4","title":"Navodila za namestitev Ubuntu 18.04 Server + ROS Melodic na RaspberryPi 4","text":"<ul> <li>Headless uporaba RPI </li> <li>Povezava preko SSH </li> <li>SSH poveza z Visual Studio Code </li> </ul>"},{"location":"additional/#namestitev-ubuntu-1804-server","title":"Namestitev Ubuntu 18.04 Server","text":"<p>Uporabi Disc Management in formatiraj 16 Gb SD kartico </p> <p>Snemi ubuntu-18.04.5-preinstalled-server-arm64+raspi4.img.xz</p> <p>Extrahiraj sliko (7zip) </p> <p>Sledi navodilom za namestitev.</p> <p>Na RaspberryPi priklopi ekran, mi\u0161ko in tipkovnico, se prijavi v ubuntu sistem</p> <p><pre><code>username: ubuntu\npassword: ubuntu\n</code></pre> in spremeni geslo.</p> <p>Sledi navodilom za postavitev mre\u017ee in SSH.</p> <p>Spremeni geslo: </p> <pre><code>sudo passwd ubuntu \n</code></pre>"},{"location":"additional/#namestitev-ros","title":"Namestitev ROS","text":"<p>Pove\u017ei se preko SSH </p> <p>Sledi navodilom, namesti\u0161 ROS-Base (ker je Ubuntu server, nima smisla name\u0161\u010dati grafi\u010dna orodja)</p> <p>Desni mi\u0161kin klik je \u201cpaste\u201d v cmd. </p> <p>Ko namestis, naredi <code>catkin_ws</code> </p> <pre><code>cd\nmkdir catkin_ws \ncd catkin_ws \nmkdir src \ncd .. \ncatkin_make \n</code></pre> <p>Dodaj \u0161e source za ROS spremenljivke </p> <pre><code>echo \"source ~/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc \nsource ~/.bashrc \n</code></pre>"},{"location":"additional/#nastavitev-staticnega-ip","title":"Nastavitev stati\u010dnega IP","text":"<p>Vir</p> <p>S spodnjim ukazom dobi seznam vseh mre\u017enih naprav: <pre><code>ifconfig\n</code></pre> Poi\u0161\u010di ustrezno mre\u017eno kartico (po navadi je <code>eth0</code>).</p> <p>Postavi se v <code>/etc/netplan</code> <pre><code>cd /etc/netplan\n</code></pre> in odpri <code>01-netcfg.yaml</code> (\u010de je ni, preveri z <code>ll</code>)</p> <pre><code>sudo nano /etc/netplan/01-netcfg.yaml\n</code></pre> <p>Dodaj spodnjo kodo, kjer nastavi\u0161 ustrezne mre\u017ene nastavitve. Pozorni bodite na ustrezne zamike (uporabite presledke ne tabulator).</p> <pre><code>network: \n   ethernets: \n      eth0: \n         dhcp4: false \n         addresses: \n            - 192.168.65.60/24 \n         gateway4: 192.168.65.254 \n         nameservers: \n            addresses: [192.168.65.14, 193.2.1.66] \n   version: 2 \n</code></pre> <p>Na koncu ponovno za\u017eeni netplan <pre><code>sudo netplan apply\n</code></pre> ter preveri, \u010de so nastavitve pravilne z <pre><code>ifconfig\n</code></pre></p>"},{"location":"additional/#povezava-s-ssh","title":"Povezava s SSH","text":"<p>V Win CMD se pove\u017ee\u0161 s: <pre><code>ssh RPI_uporabnisko_ime@RPI_IP \n</code></pre></p>"},{"location":"additional/#povezava-z-vs-code","title":"Povezava z VS Code","text":"<p>Sledi navodilom</p> <p>Pozor! Potrebuje\u0161 delujo\u010do mre\u017eno povezavo!</p>"},{"location":"additional/#gpio-na-raspberrypi","title":"GPIO na RaspberryPi","text":"<p>rpi.gpio</p> <p>Namestitev:</p> <pre><code>sudo apt-get update\nsudo apt-get install python-rpi.gpio\n</code></pre> <p>Dodaj trenutnega uporabnika v skupino <code>dialout</code>: <pre><code>sudo adduser $USER dialout\n</code></pre> in ponovno za\u017eeni RPi.</p> <p>Uporaba:</p> <pre><code>import rospy\nimport RPi.GPIO as GPIO\n\n# button GPIO\n    # button 1 - GPIO 11\n    # button 2 - GPIO 12\n\n# LED GPIO\n    # Green 1 - GPIO 2\n    # Green 2 - GPIO 3\n    # Yellow 1 - GPIO 4\n    # Yellow 2 - GPIO 5\n    # Red 1 - GPIO 6\n    # Red 2 - GPIO 7\n\n\ndef resetLed():\n     # nastavi in resetiraj vse LED\n    for ii in range(2,8):\n        # nastavi IO kot izhode\n        GPIO.setup(ii,GPIO.OUT)\n        # postavi izhode na nizek nivo\n        GPIO.output(ii,False)\n\nif __name__ == '__main__':\n    # node init\n    rospy.init_node('test_gpio_rpi')\n    # set GPIO as BCM\n    GPIO.setmode(GPIO.BCM)\n    # reset LED\n    resetLed()\n    # set button1 as input\n    GPIO.setup(11, GPIO.IN)\n    # set loop to 10 Hz\n    rate = rospy.Rate(10)\n\n    while not rospy.is_shutdown():\n        # read GPIO\n        gpio_state = GPIO.input(11)\n        \"\"\"\n        interrupt definition\n        GPIO.add_event_detect(gpio_num, detected_edge, callback, bouncetime)\n        GPIO.add_event_detect(BUTTON_GPIO, GPIO.RISING, callback=button_callback, bouncetime=500)\n        \"\"\"\n        GPIO.output(2, False)\n        if gpio_state:\n            GPIO.output(2, True)\n        rate.sleep()\n\n    # clean GPIO settings after stop\n    GPIO.cleanup()\n</code></pre>"},{"location":"additional/#sick-nanoscan3","title":"SICK NanoScan3","text":"<p>Manual - wiki</p> <ul> <li>1651 measurements</li> <li>angle resolution: 0.002909 rad</li> <li>scan angle: 275\u00b0</li> </ul>"},{"location":"additional/#install-ros-support","title":"Install ROS support","text":"<pre><code>sudo apt-get install ros-melodic-sick-safetyscanners\n</code></pre>"},{"location":"additional/#run-the-driver","title":"Run the driver","text":"<pre><code>roslaunch sick_safetyscanners sick_safetyscanners.launch sensor_ip:=&lt;sensor ip&gt; host_ip:=&lt;host ip&gt;\n</code></pre>"},{"location":"additional/#published-topics","title":"Published topics","text":"<p>Topic: <code>/sick_safetyscanners/scan</code></p> <p>Message type: <code>sensor_msgs/LaserScan</code></p>"},{"location":"additional/#linux-ukazi","title":"Linux ukazi","text":"<p>Uporabni ukazi v Linux okolju</p> <p>Dostop to root direktorija: <pre><code>cd /\n</code></pre> Premik v prej\u0161njo mapo: <pre><code>cd ..\n</code></pre> Premik v doma\u010do mapo: <pre><code>cd /home/$user$\ncd ~\n</code></pre> Izpis trenutne poti: <pre><code>pwd\n</code></pre> Prika\u017ei vsebino mape: <pre><code>ls\n</code></pre> Prika\u017ei tudi skrito vsebino mape: <pre><code>ls -l\n</code></pre> Ustvari novo mapo <code>my_folder</code>: <pre><code>mkdir my_folder\n</code></pre> Izbri\u0161i prazno mapo <code>my_folder</code>: <pre><code>rmdir my_folder\n</code></pre> Izbri\u0161i mapo <code>my_folder</code>, ki ni prazna: <pre><code>rm -rf my_folder\n</code></pre> Spremeni pravice datoteke <code>my_file</code> v executable: <pre><code>chmod +x my_file\n</code></pre> Ustvari novo datoteko <code>my_file.py</code> <pre><code>touch my_file.py\n</code></pre> Odpri datoteko <code>my_file.py</code> v Visual Studio Code: <pre><code>code my_file.py\n</code></pre> Odpri datoteko <code>my_file.py</code> v konzolnem urejevalniku besedila <code>nano</code>: <pre><code>nano my_file.py\n</code></pre></p>"},{"location":"introduction/","title":"Introduction to ROS","text":"<p>Welcome to the ROS FE workshop. In this part of the workshop you will learn the fundamentals of ROS.</p>"},{"location":"introduction/#why-ros","title":"Why ROS?","text":"<p>ROS is an open-source, meta-operating system for your robot. It provides the services you would expect from an operating system, including hardware abstraction, low-level device control, implementation of commonly-used functionality, message-passing between processes, and package management. It also provides tools and libraries for obtaining, building, writing, and running code across multiple computers. </p> <p>ROS has three levels of concepts: the Filesystem level, the Computation Graph level, and the Community level.</p>"},{"location":"introduction/#ros-filesystem-level","title":"ROS Filesystem Level","text":"<p>The basic unit for software code organization in ROS is a package. It can contain code for processes, liberaries, datasets, configuration files and custom communication types definitions. Packages can be sensibly grouped into metapackages. Each package contains a package manifest (package.xml) that provides the metadata about the package.</p>"},{"location":"introduction/#ros-computation-graph-level","title":"ROS Computation Graph Level","text":"<p>In ROS, processes run as nodes in a peer-to-peer network processing data together. This network is called ROS Computation Graph and it is supported by the name registration and lookup services of the ROS Master, by the parameter storing and serving services of the Parameter Server, and by the ROS logging mechanism. ROS nodes communicate by excanging data using messages in communication models called topics, services and actions.</p>"},{"location":"introduction/#ros-community-level","title":"ROS Community Level","text":"<p>There is a large number of ROS developers and robotic systems developers using ROS worldwide. Separate communities can exchange software and knowledge using ROS distributions, code repositories, the ROS Wiki and ROS Answers forums, blog and mailing lists. To get the participants of this course acquainted with the availabe resources, reading through some of the ROS Wiki topics will be encouraged by providing links to the ROS Wiki contents.</p>"},{"location":"introduction/#ros-setup","title":"ROS setup","text":""},{"location":"introduction/#roscore","title":"roscore","text":"<ul> <li>takes care of communicaiton between different ROS functionalities</li> <li>it can run only one at once</li> <li>connects different ROS system into one ROS network</li> </ul> <pre><code>roscore\n</code></pre>"},{"location":"introduction/#catkin-workspace","title":"catkin workspace","text":"<p>CATKIN is an official build system for ROS</p> <pre><code>cd\nmkdir catkin_ws\ncd catkin_ws\nmkdir src\ncatkin_make\n</code></pre> <p>Alternative is to use <code>catkin build</code> (beforehand you need to remove devel and build folders).</p> <p>Conect console with ROS variables <pre><code>cd devel\nsource setup.bash\n</code></pre></p> <p>To do this automatically when the console is opened, add to <code>bashrc.sh</code> <pre><code>echo \"source ~/catkin_ws/devel/setup.bash\" &gt;&gt; ~/.bashrc\nsource ~/.bashrc\n</code></pre></p>"},{"location":"introduction/#packages","title":"Packages","text":"<p>Packages are independent units, that can be re-used.</p>"},{"location":"introduction/#new-package","title":"New package","text":"<p>Go to <code>catkin_ws/src/</code> folder.</p> <p>Basic syntax: <pre><code>catkin_create_pkg &lt;package_name&gt; [depend1] [depend2] [depend3]\n</code></pre></p> <p>Create new package <code>rpi_test</code>:</p> <pre><code>cd ~/catkin_ws/src\ncatkin_create_pkg rpi_test rospy std_msgs\ncd ..\ncatkin_make\n</code></pre>"},{"location":"introduction/#node","title":"Node","text":"<p>Nodes are processes:</p> <ul> <li>used for calculations,</li> <li>that run inside robotic application,</li> <li>grouped into packages,</li> <li>that communicate with each other (topics, servers, actions, parameter servers). </li> </ul> <p>Why to use nodes:</p> <ul> <li>reduce code complexity,</li> <li>the code is more error-resistant,</li> <li>use of different programming languages.</li> </ul>"},{"location":"introduction/#new-node","title":"New node","text":"<p>Nodes are scripts that are located inside <code>scripts</code> folder. <pre><code>roscd rpi_test\nmkdir scripts\ncd scripts\n</code></pre> Create new script <code>my_first_node.py</code>: <pre><code>touch my_first_node.py\n</code></pre></p> <p>Change the access permissions of the file to executable: <pre><code>chmod +x my_first_node.py\n</code></pre></p> <p>Open script with Visual Studio Code: <pre><code>code my_first_node.py\n</code></pre></p> <p>The minimal working example for node:</p> my_fist_node.py<pre><code>#!/usr/bin/env python\n\nimport rospy\n\nif __name__ == '__main__':\n  rospy.init_node('my_first_python_node')\n  rospy.loginfo('This node has been started.')\n  rospy.sleep(1)\n  print('Exit now')\n</code></pre> <p>Only one node with specific name can be run at a time. If you want to run more instances of the same node, change: <pre><code>  rospy.init_node('my_first_python_node', anonymous=True)\n</code></pre></p> <p>To run, write <pre><code>python my_first_node.py\n</code></pre></p>"},{"location":"introduction/#new-node-class","title":"New node - class","text":"my_fist_node_class.py<pre><code>#!/usr/bin/env python\n\nimport rospy\n\nclass hello_world():\n\n  def __init__(self):\n    # init variables\n    self.delay = 5\n    self.ctrl_c = False\n    rospy.on_shutdown(self.shutdownhook)\n\n  def shutdownhook(self):\n    # works better than the rospy.is_shutdown()\n    # this code is run at ctrl + c\n    rospy.loginfo('This node has been terminated.')\n    self.ctrl_c = True\n\n  def test_node(self): \n    rospy.loginfo('This node has been started.')\n    rospy.sleep(self.delay)\n    print('Exit now')\n\nif __name__ == '__main__':\n  # initialise node\n  rospy.init_node('my_first_python_node')\n  # initialise class\n  first_node = hello_world()\n  try:\n    first_node.test_node()\n  except rospy.ROSInterruptException:\n    pass\n</code></pre>"},{"location":"introduction/#debug","title":"DEBUG","text":"<ul> <li><code>rosrun &lt;pkg name&gt; &lt;node name&gt;</code> - run specific node</li> <li><code>rosnode list</code> - list of all active nodes</li> <li><code>rosnode info &lt;node name&gt;</code> - information about hte node</li> <li><code>rosnode kill &lt;node name&gt;</code> - shut down node</li> <li><code>rosnode ping &lt;node name&gt;</code> - ping node (check, if it is working)</li> </ul>"},{"location":"introduction/#examples-for-raspberry-pi","title":"Examples for Raspberry Pi","text":"<p>Download examples on RaspberryPi.</p> <p>Go to <code>src</code> directory: <pre><code>roscd\ncd ..\ncd src\n</code></pre></p> <p>Clone from GitHub: <pre><code>git clone https://github.com/ROS-FE/rpi_ros_examples.git .\n</code></pre></p> <p>Build the packages: <pre><code>roscd\ncd ..\ncatkin_make\n</code></pre></p>"},{"location":"introduction/#topics","title":"Topics","text":"<p>Topic is:</p> <ul> <li>a communication channel through which nodes exchange messages</li> <li>one-way messaging (publisher&gt; subscriber)</li> <li>anonymous</li> <li>topic has its own message type (list of standars message types)</li> <li>ROS master takes care of the proper publisher/subscriber connection</li> <li>each node can have multiple publishers/subscribers for different topics</li> </ul>"},{"location":"introduction/#example","title":"Example","text":"<p>Turn on LED on button press.</p> <p></p>"},{"location":"introduction/#publisher","title":"Publisher","text":"<p>Syntax for publisher: <pre><code>pub = rospy.Publisher('/topic_name', msg_type, queue_size=10)\n</code></pre></p> <p>Example code:</p> button_publisher.py<pre><code>#!/usr/bin/env python\n\nimport rospy\nimport RPi.GPIO as GPIO\nfrom std_msgs.msg import Bool\n\n# buttons GPIO pins \n#   button 1 - gpio 11\n#   button 2 - gpio 12\n\nclass rpi_button():\n\n    def __init__(self):\n        # init variables\n        self.BUTTON_GPIO = 11\n        # set GPIO kot BCM\n        GPIO.setmode(GPIO.BCM)\n        # set button IO as input\n        GPIO.setup(self.BUTTON_GPIO, GPIO.IN)\n        # set loop frequency to 10 Hz\n        self.rate = rospy.Rate(10)\n\n        # define publisher\n        # rospy.Publisher(\"topic_name\", varType, queue_size)\n        self.pub = rospy.Publisher('/button_state', Bool, queue_size=10)\n\n        self.ctrl_c = False\n        rospy.on_shutdown(self.shutdownhook)\n\n    def read_button(self):\n        while not self.ctrl_c:\n            #  read GPIO pin\n            gpio_state = GPIO.input(self.BUTTON_GPIO)\n            # define msg as Bool variable\n            self.msg = Bool()\n            # msg has a data \"data\"\n            self.msg.data = gpio_state\n            # send msg\n            self.publish_once()\n\n    def publish_once(self):\n        \"\"\"\n        This is because publishing in topics sometimes fails the first time you publish.\n        In continuous publishing systems, this is no big deal, but in systems that publish only\n        once, it IS very important.\n        \"\"\"\n        while not self.ctrl_c:\n            connections = self.pub.get_num_connections()\n            if connections &gt; 0:\n                self.pub.publish(self.msg)\n                #rospy.loginfo(\"Msg Published\")\n                break\n            else:\n                self.rate.sleep()\n\n    def shutdownhook(self):\n        # works better than the rospy.is_shutdown()\n        # this code is run at ctrl + c\n\n        # clear all GPIO settings\n        GPIO.cleanup()\n        self.ctrl_c = True\n\nif __name__ == '__main__':\n    # initialise node\n    rospy.init_node('button_state_publisher', anonymous=True)\n\n    # initialise class\n    btn = rpi_button()\n    try:\n        btn.read_button()\n    except rospy.ROSInterruptException:\n        pass\n</code></pre> <p>To test the code run <pre><code>rosrun rpi_feros button_publisher.py\n</code></pre> check the list of topics (look for <code>/button_state</code>) <pre><code>rostopic list\n</code></pre> Then listen to that topic <pre><code>rostopic echo /button_state -c\n</code></pre> and press the button on RaspberryPi.</p>"},{"location":"introduction/#subscriber","title":"Subscriber","text":"<p>Syntax for subscriber: <pre><code>sub = rospy.Subscriber('/topic_name', msg_type, callback_fcn)\n</code></pre> Example code: led_actuator.py<pre><code>#!/usr/bin/env python\n\nimport rospy\nfrom std_msgs.msg import Bool\nimport RPi.GPIO as GPIO\n\n# GPIO za LED:\n#   Green 1 - GPIO 2\n#   Green 2 - GPIO 3\n#   Yellow 1 - GPIO 4\n#   Yellow 2 - GPIO 5\n#   Red 1 - GPIO 6\n#   Red 2 - GPIO 7\n\nclass rpi_led():\n\n    def __init__(self):\n        # init variables\n        self.LED_GPIO = 7\n        # set GPIO kot BCM\n        GPIO.setmode(GPIO.BCM)\n        # set all leds\n        for ii in range(2,8):\n            # set IO as outputs\n            GPIO.setup(ii,GPIO.OUT)\n\n        # define subscriber\n        # rospy.Subscriber('topic_name', varType, callback)\n        self.sub = rospy.Subscriber('/button_state', Bool, self.button_state_callback)\n\n        self.ctrl_c = False\n        rospy.on_shutdown(self.shutdownhook)\n\n    def button_state_callback(self, msg):\n        # the code that is executed when data is received\n        # turn on LED\n        GPIO.output(self.LED_GPIO, msg.data)\n\n    def resetLed(self):\n        # reset all leds\n        for ii in range(2,8):\n            # turn off all leds\n            GPIO.output(ii,False)\n\n    def shutdownhook(self):\n        # works better than the rospy.is_shutdown()\n        # this code is run at ctrl + c\n\n        # clear all settings\n        GPIO.cleanup()\n        self.ctrl_c = True\n\nif __name__ == '__main__':\n    # initialise node\n    rospy.init_node('led_actuator')\n    # initialise class\n    led_act = rpi_led()\n    # reset leds\n    led_act.resetLed()\n    try:\n        # loop\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n</code></pre></p> <p>To test the code run <pre><code>rosrun rpi_feros led_actuator.py\n</code></pre></p> <p>After that check topics (loook for <code>/button_state</code>): <pre><code>rostopic list\n</code></pre></p> <p>Use <code>rostopic pub</code> to turn LED on and off: <pre><code>rostopic pub /button_state std_msgs/Bool \"data: True\"\nrostopic pub /button_state std_msgs/Bool \"data: False\"\n</code></pre></p> <p>To test both (publisher and subscriber), run each in  the invidual terminal: <pre><code>rosrun rpi_feros button_publisher.py\n</code></pre> and <pre><code>rosrun rpi_feros led_actuator.py\n</code></pre> When pressing the button on RPi, the LED should turn on.</p>"},{"location":"introduction/#debug_1","title":"DEBUG","text":"<ul> <li><code>rostopic -h</code> - rostopic help</li> <li><code>rostopic list</code> - list of all active topics</li> <li><code>rostopic echo &lt;topic name&gt;</code> - listen to selected topic</li> <li><code>-c</code> - clear output each time</li> <li><code>-n2</code> - print only 2 outputs</li> <li><code>rostopic info &lt;topic name&gt;</code> - information about topic</li> <li><code>rostopic pub &lt;topic name&gt;</code> + <code>Tab</code> for autocomplete - publish data</li> <li><code>-1</code> - publish only once</li> <li><code>-r5</code>- publish with 5 Hz</li> </ul>"},{"location":"introduction/#exercise","title":"Exercise","text":"<p>Turn on LED if the object is closer than 0.2 m.</p> <p></p>"},{"location":"introduction/#roslaunch","title":"Roslaunch","text":"<p>Roslaunch is a tool for easily launching multiple ROS nodes as well as setting parameters. Roslaunch takes in one or more XML configuration files (with the .launch extension) that specify the parameters to set and nodes to launch, as well as the machines that they should be run on.</p> <p>Basic sytax is <pre><code>&lt;launch&gt;\n  &lt;param name=\"/parameter_name\" type=\"variable_type\" value=\"variable_value\"/&gt;\n  &lt;node name=\"name_of_the_node\" pkg=\"name_of_the_package\" type=\"source_file.py\" ns=\"namespace\" args=\"optional arguments\"/&gt;\n  &lt;include file=\"included.launch\"&gt;\n    &lt;arg name=\"arg_name\" value=\"arg_val\" /&gt;\n  &lt;/include&gt;\n&lt;/launch&gt;\n</code></pre></p>"},{"location":"introduction/#new-launch","title":"New .launch","text":"<p>Create new package <code>rpi_feros_bringup</code> used for launch files: <pre><code>roscd\ncd ..\ncd src\ncatkin_create_pkg rpi_feros_bringup\n</code></pre> and do <code>catkin_make</code>.</p> <p>Go the new package and create folder <code>launch</code> <pre><code>roscd rpi_feros_bringup\nmkdir launch\ncd launch\n</code></pre></p> <p>Inside the folder create new file <code>feros.launch</code> <pre><code>touch rpi_led.launch\ncode rpi_led.launch\n</code></pre></p> <p>Copy the following lines rpi_led.launch<pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n&lt;launch&gt;\n    &lt;node name=\"btn_pub\" pkg=\"rpi_feros\" type=\"button_publisher.py\" output=\"screen\"/&gt;\n    &lt;node name=\"led_act\" pkg=\"rpi_feros\" type=\"led_actuator.py\" output=\"screen\"/&gt;   \n&lt;/launch&gt;\n</code></pre></p> <p>To run the <code>rpi_led.launch</code> use <code>roslaunch</code> function <pre><code>roslaunch rpi_feros_bringup rpi_led.launch\n</code></pre></p> <p>By running this .launch file three things are started</p> <ul> <li><code>roscore</code> (automatically),</li> <li><code>button_publisher.py</code>, and</li> <li><code>led_actuator.py</code>.</li> </ul>"},{"location":"introduction/#ros-network","title":"ROS network","text":"<ul> <li>one ROS master in the entire network</li> <li>all nodes must use the same ROS master (<code>ROS_MASTER_URI</code>)</li> <li>two-way connection between devices</li> <li>each device must present itself with a name that other devices recognize</li> </ul> <p>http://wiki.ros.org/ROS/Tutorials/MultipleMachines</p> <p>http://wiki.ros.org/ROS/NetworkSetup</p>"},{"location":"introduction/#connection","title":"Connection","text":"<p><code>ping</code> the remote computer (hostname: IP or name) <pre><code>ping 192.168.65.60\n</code></pre></p> <p>Use <code>ssh</code> to connect to remote computer and ping your computer <pre><code>ssh student@192.168.65.60\nping 192.168.65.50\n</code></pre></p>"},{"location":"introduction/#ros_master_uri","title":"ROS_MASTER_URI","text":"<p>ROS master is set with variable <code>ROS_MASTER_URI</code>. It needs to be set withing each terminal. <pre><code>export ROS_MASTER_URI=http://[hostname]:11311\n</code></pre> To check, use <pre><code>echo $ROS_MASTER_URI\n</code></pre></p> <p>Set parameter <code>ROS_IP</code> for IP or <code>ROS_HOSTNAME</code>for hostname if you have multiple addresses for a computer and need to force ROS to a particular one.</p> <p>To do this automatically, add command to <code>bashrc</code> <pre><code>sudo nano ~/.bashrc\n</code></pre> Add <pre><code>export ROS_MASTER_URI=http://[hostname]:11311\n</code></pre></p> <p>ATTENTION!</p> <p>This can cause a problem, it you would like to run ROS master on the local computer.</p>"},{"location":"introduction/#test-connection","title":"Test connection","text":"<p>It is important to test connection in both ways:</p> <ul> <li>master (publisher) &gt;&gt;&gt; others (subscriber)</li> <li>master (subscribers) &lt;&lt;&lt; others (publisher) </li> </ul> <p>Publisher: <pre><code>rostopic pub /test_connection std_msgs/Bool \"data: True\"\n</code></pre></p> <p>Subscriber: <pre><code>rostopic list\n\nrostopic echo /test_connection\n</code></pre></p>"},{"location":"introduction/#exercise_1","title":"Exercise","text":"<p>Connect to master computer with Sick Nanoscan3 and connect to topic <code>/sick_safetyscanners/scan</code>.</p>"},{"location":"introduction/#services","title":"Services","text":"<ul> <li>Server/client system</li> <li>Synchronous operation</li> <li>For calculation and quick actions</li> <li>One message type for Request, another message type for Response</li> <li>A server is only one that can respond to multiple clients</li> </ul>"},{"location":"introduction/#example_1","title":"Example","text":"<p>Turn on LED on button press using interrupts.</p> <p></p>"},{"location":"introduction/#server","title":"Server","text":"<p>Syntax for service server: <pre><code>service = rospy.Service('/service_name', msg_type, handle_fcn)\n</code></pre></p> <p>Example code:</p> led_service_server.py<pre><code>#!/usr/bin/env python\n\nimport rospy\nfrom std_srvs.srv import SetBool\nimport RPi.GPIO as GPIO\n\nclass ledServer():\n\n    def __init__(self):\n        # init variables\n        self.LED_GPIO = 2\n        # set GPIO kot BCM\n        GPIO.setmode(GPIO.BCM)\n        # set all leds\n        for ii in range(2,8):\n            # set IO as outputs\n            GPIO.setup(ii,GPIO.OUT)\n\n        # define service\n        # rospy.Service('service_name',varType,callback)\n        rospy.Service('/set_led_state', SetBool, self.set_led_status_callback)\n        rospy.loginfo(\"Service server started. Ready to get request.\")\n\n        self.ctrl_c = False\n        rospy.on_shutdown(self.shutdownhook)\n\n    def set_led_status_callback(self, req): \n        # code that is executed when request is received\n        # set LED to req.data\n        GPIO.output(self.LED_GPIO, req.data)\n        # server response\n        return {'success': True, 'message':'Successfully changed LED state.'}\n\n    def resetLed(self):\n        # reset all leds\n        for ii in range(2,8):\n            # turn off all leds\n            GPIO.output(ii,False)\n\n    def shutdownhook(self):\n        # works better than the rospy.is_shutdown()\n        # this code is run at ctrl + c\n\n        # clear all settings\n        GPIO.cleanup()\n        self.ctrl_c = True\n\nif __name__ == '__main__':\n    # initialise node\n    rospy.init_node('led_actuator')\n    # initialise class\n    led_server = ledServer()\n    # reset leds\n    led_server.resetLed()\n    try:\n        # loop\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n</code></pre> <p>To test the code run <pre><code>rosrun rpi_feros led_service_server.py \n</code></pre> and check the list of services (look for <code>/set_led_state</code>) <pre><code>rosservice list\n</code></pre> Use <code>rosservice call</code> to test the server <pre><code>rosservice call /set_led_state \"data: True\"\nrosservice call /set_led_state \"data: False\" \n</code></pre></p>"},{"location":"introduction/#client","title":"Client","text":"<p>Syntax for service proxy (client): <pre><code>rospy.wait_for_service('/service_name')\n\ntry:\n  client = rospy.ServiceProxy('/service_name',msg_type)\n  ...\nexcept rospy.ServiceException as e:\n  rospy.logwarn('Service failed' + str(e))\n</code></pre></p> <p>Example: button_service_client.py<pre><code>#!/usr/bin/env python\n\nimport rospy\nfrom std_srvs.srv import SetBool\nimport RPi.GPIO as GPIO\n\nclass buttonClient():\n\n    def __init__(self):\n        # init variables\n        self.BUTTON_GPIO = 11\n        self.LED_STATE = False\n        # set GPIO kot BCM\n        GPIO.setmode(GPIO.BCM)\n        # set button GPIO as input\n        GPIO.setup(self.BUTTON_GPIO, GPIO.IN)\n        # set interrupt\n        # GPIO.add_event_detect(gpio_num, edge, callback, bouncetime)\n        GPIO.add_event_detect(self.BUTTON_GPIO, GPIO.RISING, callback=self.button_callback, bouncetime=500)\n\n        # define service proxy\n        # rospy.ServiceProxy('service_name', varType)\n        # wait for service\n        rospy.wait_for_service('/set_led_state')\n        # define proxy \n        self.set_led_state = rospy.ServiceProxy('/set_led_state', SetBool)\n\n        self.ctrl_c = False\n        rospy.on_shutdown(self.shutdownhook)\n\n    def button_callback(self, channel):\n        # code that is called from interrupt\n        # get the button state\n        power_on_led = GPIO.input(self.BUTTON_GPIO)\n\n        # change LED state\n        self.LED_STATE = not self.LED_STATE\n\n        try:\n            # send request, get response\n            resp = self.set_led_state(self.LED_STATE)\n            # print response\n            print(resp)\n        except rospy.ServiceException as e:\n            # in case of error\n            rospy.logwarn(e)\n\n    def shutdownhook(self):\n        # works better than the rospy.is_shutdown()\n        # this code is run at ctrl + c\n\n        # clear all settings\n        GPIO.cleanup()\n        self.ctrl_c = True\n\nif __name__ == '__main__':\n    # initialise node\n    rospy.init_node('button_monitor')\n    # initialise class\n    button_client = buttonClient()\n    try:\n        # loop\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n</code></pre></p> <p>To test, run both server and client in seperate terminals <pre><code>rosrun rpi_feros led_service_server.py \nrosrun rpi_feros button_service_client.py\n</code></pre> With a button press, LED should turn on and off.</p>"},{"location":"introduction/#debug_2","title":"DEBUG","text":"<ul> <li><code>rosservice list</code> - list of all active services</li> <li><code>rosservice info &lt;service name&gt;</code> - information about the selected service</li> <li><code>rosservice call &lt;service name&gt;</code> - request to service server from the console</li> </ul>"},{"location":"introduction/#exercise_2","title":"Exercise","text":"<p>Use buttons to shift active LED left or right.</p> <p></p>"},{"location":"introduction/#custom-messages","title":"Custom messages","text":"<p>Topics messages: <code>.msg</code></p> <p>Service messages: <code>.srv</code></p> <p>Service message has two parts <pre><code>Request msg\n---\nResponse msg\n</code></pre></p> <p>Use of <code>msg</code> primitives to define custom messages.</p> <p>MSG:</p> <ul> <li>std_msgs</li> <li>sensor_msgs</li> <li>geometry_msgs</li> <li>actionlib_msgs</li> <li>...</li> </ul> <p>SRV:</p> <ul> <li>std_srvs</li> <li>...</li> </ul>"},{"location":"introduction/#msg","title":"MSG","text":"<p>We will create new topic message <code>ledStatus</code> composed of <pre><code>int64 ledNumber\nstring ledStatus\n</code></pre> Create new package <code>rpi_msgs</code> <pre><code>cd ~/catkin_ws/src\ncatkin_create_pkg rpi_msgs rospy std_msgs\n</code></pre> and build it <pre><code>roscd\ncd ..\ncatkin_make\n</code></pre> Go to the package and create new folder <code>msg</code>: <pre><code>roscd rpi_msgs\nmkdir msg\ncd msg\n</code></pre></p> <p>Create new file <code>ledStatus.msg</code> <pre><code>touch ledStatus.msg\ncode ledStatus.msg\n</code></pre> and copy the following lines: <pre><code>int64 ledNumber\nstring ledStatus\n</code></pre></p> <p>Open <code>package.xml</code> in <code>rpi_msgs</code> package <pre><code>code package.xml\n</code></pre> and add the following lines package.xml<pre><code>&lt;build_depend&gt;message_generation&lt;/build_depend&gt;\n&lt;exec_depend&gt;message_runtime&lt;/exec_depend&gt;\n</code></pre></p> <p>Open <code>CMakeLists.txt</code> in <code>rpi_msgs</code> package <pre><code>code CMakeLists.txt\n</code></pre> and add the following lines CMakeLists.txt<pre><code>find_package(catkin REQUIRED COMPONENTS\n  rospy\n  std_msgs\n  message_generation\n)\n</code></pre></p> CMakeLists.txt<pre><code># Generate messages in the 'msg' folder\nadd_message_files(\n  FILES\n  ledStatus.msg\n)\n</code></pre> CMakeLists.txt<pre><code># Generate added messages and services with any dependencies listed here\ngenerate_messages(\n  DEPENDENCIES\n  std_msgs\n)\n</code></pre> CMakeLists.txt<pre><code>catkin_package(\n  # INCLUDE_DIRS include\n  # LIBRARIES my_robot_msgs\n  CATKIN_DEPENDS rospy std_msgs message_runtime\n  # DEPENDS system_lib\n)\n</code></pre> <p>After that do <code>catkin_make</code> <pre><code>roscd\ncd ..\ncatkin_make\n</code></pre></p> <p>After the build is finish you can check if the message <code>rpi_msgs/ledStatus</code> is available <pre><code>rosmsg list |grep rpi\n</code></pre></p>"},{"location":"introduction/#srv","title":"SRV","text":"<p>We will create new service message <code>safetyZone.srv</code> composed of <pre><code>int16 zone\n---\nbool success\nstring message\n</code></pre></p> <p>Go to the package <code>rpi_msgs</code> <pre><code>roscd rpi_msgs\n</code></pre> and create new folder <code>srv</code>: <pre><code>mkdir srv\ncd msg\n</code></pre></p> <p>Create new file <code>safetyZone.srv</code> <pre><code>touch safetyZone.srv\ncode safetyZone.srv\n</code></pre> and copy the following lines: <pre><code>int16 zone\n---\nbool success\nstring message\n</code></pre></p> <p>Open <code>CMakeLists.txt</code> in <code>rpi_msgs</code> package <pre><code>code CMakeLists.txt\n</code></pre> and add the following lines CMakeLists.txt<pre><code># Generate services in the 'srv' folder\nadd_service_files(\n  FILES\n  safetyZone.srv\n)\n</code></pre></p> <p>After that do the <code>catkin_make</code> <pre><code>roscd\ncd ..\ncatkin_make\n</code></pre></p> <p>After the build is finish you can check if the service message <code>rpi_msgs/safetyZone</code> is available <pre><code>rossrv list |grep rpi\n</code></pre></p>"},{"location":"introduction/#use-of-custom-msg-and-srv","title":"Use of custom MSG and SRV","text":"<p>To use custom messages, you need to do some changes of the <code>package.html</code> and the <code>CMakeLists.txt</code> of the package where you want to use them (in our case <code>rpi_feros</code>)</p> package.html<pre><code>&lt;depend&gt;rpi_msgs&lt;/depend&gt;\n</code></pre> CMakeLists.txt<pre><code>find_package(catkin REQUIRED COMPONENTS\n  rospy\n  std_msgs\n  rpi_msgs\n)\n</code></pre> <p>To include new message in python code add <pre><code>from rpi_msgs.msg import ledStatus, safetyZone\n</code></pre></p>"},{"location":"introduction/#debug_3","title":"DEBUG","text":"<ul> <li><code>rosmsg list</code> - list of available messages</li> <li> <p><code>rosmsg show &lt;msg name&gt;</code> - show message details</p> </li> <li> <p><code>rossrv list</code> - list of available service messages</p> </li> <li><code>rossrv show &lt;srv msg name&gt;</code> - show service message details</li> </ul>"},{"location":"introduction/#exercise_3","title":"Exercise","text":"<p>Turn on LEDs regarding to distance \\(d\\) from safety sensor:</p> <ul> <li>green: \\(d\\) &gt; 0.4 m</li> <li>yellow: 0.4 m &gt; \\(d\\) &gt; 0.2 m</li> <li>red: \\(d\\) &lt; 0.2 m</li> </ul> <p></p>"},{"location":"introduction/#actions","title":"Actions","text":"<ul> <li><code>actionlib</code> library</li> <li>server/client system</li> <li>asynchronous operation</li> <li>used for longer lasting functionalities</li> <li>you can perform other tasks while basic functionality is called</li> <li>action msg is composed of individual messages for Goal, Feedback and Result</li> </ul> <p>How to recognise action?</p> <p>Use <code>rostopic list</code> and look for the following structure (<code>as</code> stands for <code>action server</code>): <pre><code>as_name/cancel\nas_name/feedback\nas_name/goal\nas_name/result\nas_name/status\n</code></pre> (<code>as_name</code> is action server namespace).</p>"},{"location":"introduction/#action-msg","title":"Action MSG","text":"<p>Action msgs can be defined in package <code>rpi_msgs</code>. Create new folder <code>action</code> and inside new file <code>runningLed.action</code>. <pre><code>roscd rpi_msgs\nmkdir action\ncd ./action\ntouch runningLed.action\ncode runnngLed.action\n</code></pre> Copy the following acton msg definition: runningLed.action<pre><code># goal\nint16 numberOfRuns\n---\n# result\nint16 finalRun\n---\n# feedback\nint16 currentRun\n</code></pre></p> <p>In <code>CMakeLists.txt</code> of the <code>rpi_msgs</code> package change the following lines:</p> <p>CMakeLists.txt<pre><code>find_package(catkin REQUIRED COMPONENTS\n  rospy\n  std_msgs\n  message_generation\n  actionlib_msgs\n)\n</code></pre> CMakeLists.txt<pre><code>add_action_files(\n  FILES\n  runningLed.action\n)\n</code></pre></p> CMakeLists.txt<pre><code>generate_messages(\n  DEPENDENCIES\n  std_msgs\n  actionlib_msgs\n)\n</code></pre> <p>In <code>package.xml</code> of the <code>rpi_msgs</code> package add the following line:</p> package.xml<pre><code>&lt;build_depend&gt;actionlib_msgs&lt;/build_depend&gt;\n</code></pre> <p>Then do <code>catkin_make</code> in <code>catkin_ws</code> folder.</p>"},{"location":"introduction/#example_2","title":"Example","text":"<p>Turn on sequential LEDs n-times.</p> <p></p>"},{"location":"introduction/#action-server","title":"Action server","text":"<p>Simple action server sytnax: <pre><code>sas = actionlib.SimpleActionServer('name', actionSpec, goal_callback, auto_start=False)\nsas.start()\n\ndef goal_callback()\n  sas.publish_feedback(_feedback_)\n  sas.set_succeeded(_result_)\n\nif sas.is_preempt_requested():\n  sas.set_preempted()\n</code></pre></p> <p>Example code for simple action server:</p> ledrun_server.py<pre><code>#!/usr/bin/env python\n\nimport rospy\nimport RPi.GPIO as GPIO\n# include actionlib\nimport actionlib\n# include action msgs\nfrom rpi_msgs.msg import runningLedFeedback, runningLedResult, runningLedAction\n\n\nclass runled_server():\n\n    def __init__(self):\n        # init variables\n\n        # set GPIO kot BCM\n        GPIO.setmode(GPIO.BCM)\n        # set all leds\n        for ii in range(2,8):\n            # set IO as outputs\n            GPIO.setup(ii,GPIO.OUT)\n\n        # define simple action server\n        # actionlib.SimpleActionServer('action_name', actionType, callback, autostart)\n        self.ACserver = actionlib.SimpleActionServer('run_led', runningLedAction, self.goal_callback, False)\n        # run server\n        self.ACserver.start()\n        print('Server pripravljen')\n\n        # define loop frequency (6 Hz)\n        self.r = rospy.Rate(6)\n\n        self.ctrl_c = False\n        rospy.on_shutdown(self.shutdownhook)\n\n    def goal_callback(self, goal):\n\n        # Do lots of awesome groundbreaking robot stuff here\n        self.resetLed()\n\n        # print number of iterations \n        print(\"Stevilo iteracij: %i\" % goal.numberOfRuns)\n\n        # define feedback variable\n        feedback1 = runningLedFeedback()\n        # define result variable\n        result1 = runningLedResult()\n\n        success = True\n        doPreemt = False\n        # do number of iterations\n        for kk in range(1,goal.numberOfRuns+1):\n            # turn on individual LED (GPIO 2 - GPIO 7)\n            for ii in range(2,8):\n                # check if there was a preemt request\n                if self.ACserver.is_preempt_requested():\n                    # skip other interations\n                    print('Goal preempted.')\n                    # definie result\n                    result1.finalRun = kk\n                    # in case of preemt send result and text\n                    self.ACserver.set_preempted(result=result1,text='Goal preemted.')\n                    success = False \n                    doPreemt = True\n                    # break inside loop - turning on individual LEDs\n                    break\n                ###############################\n                # ACTIONS\n                # clear all LED\n                self.resetLed()\n                # turn on LED i\n                GPIO.output(ii,True)\n                # 6 Hz\n                self.r.sleep()\n                ############################### \n            # in case of preemt, break outside loop - iterations\n            if doPreemt:\n                break\n            # send feedback after each interation\n            feedback1.currentRun = kk\n            self.ACserver.publish_feedback(feedback1)\n\n        # send result after all iterations\n        if success:\n            # define results\n            result1.finalRun = feedback1.currentRun\n            # log\n            rospy.loginfo('Zakljuceno - Succeeded') \n            # poslji rezultat\n            self.ACserver.set_succeeded(result1)\n\n    def resetLed(self):\n        # reset all leds\n        for ii in range(2,8):\n            # turn off all leds\n            GPIO.output(ii,False)\n\n    def shutdownhook(self):\n        # works better than the rospy.is_shutdown()\n        # this code is run at ctrl + c\n\n        # clear all settings\n        GPIO.cleanup()\n        self.ctrl_c = True\n\nif __name__ == '__main__':\n    # initialise node\n    rospy.init_node('runled_server')\n    # initialise class\n    runled = runled_server()\n    # reset leds\n    runled.resetLed()\n    try:\n        # loop\n        rospy.spin()\n    except rospy.ROSInterruptException:\n        pass\n</code></pre>"},{"location":"introduction/#action-client","title":"Action client","text":"<p>Simple action client syntax: <pre><code>client = actionlib.SimpleActionClient('name', actionSpec)\n\nclient.send_goal(goal) # Sends the goal to the action server.\n\nclient.wait_for_result() # Waits for the server to finish performing the action.\n\nclient.get_result() # Prints out the result of executing the action\n\nclient.get_state() # Get current state of the server\n\n# define action server status\nPENDING = 0\nACTIVE = 1\nDONE = 2\nWARN = 3\nERROR = 4\n</code></pre></p> <p>Example code for simple action client:</p> ledrun_client.py<pre><code>#!/usr/bin/env python\n\nimport rospy\n# import actionlib\nimport actionlib\n# import action msgs\nfrom rpi_msgs.msg import runningLedAction, runningLedGoal, runningLedResult\n\n# define action server status\nPENDING = 0\nACTIVE = 1\nDONE = 2\nWARN = 3\nERROR = 4\n\nclass runled_client():\n\n    def __init__(self):\n\n        # define simple action client \n        # actionlib.SimpleActionClient('action:name', actionType)\n        self.client = actionlib.SimpleActionClient('run_led', runningLedAction)\n        # wait, until server isnt active\n        self.client.wait_for_server()\n        rospy.loginfo(\"Server is active.\")\n\n        self.ctrl_c = False\n        rospy.on_shutdown(self.shutdownhook)\n\n    def run_led_client(self, goalNum):\n\n        # define goal\n        goal = runningLedGoal()\n        goal.numberOfRuns = goalNum\n\n        # send goal \n        self.client.send_goal(goal)\n\n        '''\n        ###################################\n        # FOR PREEMT TESTING\n        # after 3 s send new goal\n        rospy.sleep(3)\n        goal.numberOfRuns = 2\n        self.client.send_goal(goal) \n        print('New goal was sent.')\n        ###################################\n        '''\n\n        # OPTION A - wait, until server doesn finish (similar to service)\n        self.client.wait_for_result()\n\n        '''\n        # OPTION B - do something else while you are waiting    \n\n        ## read current server state\n        current_state = self.client.get_state()\n\n        ## define loop frequency 1 Hz\n        r2 = rospy.Rate(1)\n\n        # until server status isnt DONE, do something else\n        while current_state &lt; DONE:\n            # action is running, so do somethin productive\n\n            # check state\n            current_state = self.client.get_state()\n            # 1 Hz\n            r2.sleep()\n\n        # is the server state is WARN\n        if current_state == WARN:\n            rospy.logwarn(\"Warning on the action server side.\")\n\n        # if the server state is ERROR\n        if current_state == ERROR:\n            rospy.logerr(\"Error on the action server side.\")\n        '''\n\n        # return result\n        return self.client.get_result() \n\n\n    def shutdownhook(self):\n        # works better than the rospy.is_shutdown()\n        # this code is run at ctrl + c\n\n        self.ctrl_c = True\n\nif __name__ == '__main__':\n    # initialise node\n    rospy.init_node('run_led_client')\n    # initialise class\n    runled = runled_client()\n\n    try:\n        # poslji goal         \n        result = runled.run_led_client(goalNum = 10)\n        # izpisi rezultat\n        print(\"Result: %i\" % result.finalRun)\n    except rospy.ROSInterruptException:\n        # v primeru napake\n        print(\"Program interrupted before completion.\")\n</code></pre>"},{"location":"introduction/#exercise_4","title":"Exercise","text":"<p>Stop execution of LEDs sequential blinking if the object is closer that 20 cm.</p>"},{"location":"introduction/#parameters","title":"Parameters","text":"<p>Parameter server: globally available dictionary within ROS master</p> <p>ROS parameter: one variable within the parameter server </p> <p>Types:</p> <ul> <li>Boolean</li> <li>Int</li> <li>Double</li> <li>String</li> <li>Lists</li> <li>...</li> </ul>"},{"location":"introduction/#example_3","title":"Example","text":"<p>Code examples: <pre><code># set parameter\nrospy.set_param('/publish_frequency', 2)\n\n# get parameter\npublish_freq = rospy.get_param('/publish_frequency')\n\n# get list of parameters\ntry:\n  rospy.get_param_names()\nexcept ROSException:\n  print(\"Could not get param names\")\n</code></pre></p> <p>Set parameter in a launch file: <pre><code>&lt;param name=\"/parameter_name\" type=\"parameter_type\" value=\"value\"/&gt;\n</code></pre></p> <pre><code>&lt;launch&gt;\n  &lt;param name=\"/publish_frequency\" type=\"int\" value=\"2\"/&gt;\n&lt;/launch&gt;\n</code></pre> <p><code>&lt;rosparam&gt;</code> is used if you want to load a list of parameters from a .yaml file <pre><code>&lt;rosparam command=\"load\" file=\"$(find &lt;package_name&gt;)/example.yaml\" /&gt;\n</code></pre></p>"},{"location":"introduction/#debug_4","title":"DEBUG","text":"<ul> <li><code>rosparam set &lt;param name&gt; &lt;value&gt;</code> - to create new parameter</li> <li><code>rosparam get &lt;param name&gt;</code> - get parameter value</li> <li><code>rosparam list</code> - get list of parameters</li> </ul>"},{"location":"introduction/#exercise_5","title":"Exercise","text":"<p>Upgrade SimpleActionClient by setting number of runs as parameter <code>/number_of_runs</code>.</p> <p>Upgrade SimpleActionServer by setting LED frequency as parameter <code>/led_frequency</code>.</p> <p>Create <code>.launch</code> file for Action Server.</p>"},{"location":"introduction/#ros-debug-tools","title":"ROS Debug tools","text":""},{"location":"introduction/#logging","title":"Logging","text":"<p>5 logging levels:</p> <ul> <li>DEBUG</li> <li>INFO<ul> <li>WARN</li> <li>ERROR<ul> <li>FATAL</li> </ul> </li> </ul> </li> </ul> <p></p> <p>Code example <pre><code>rospy.init_node('log_demo', log_level=rospy.DEBUG)\n\nwhile not rospy.is_shutdown():\n  rospy.logdebug(\"Debug msg\")\n  rospy.loginfo(\"Info msg\")\n  rospy.logwarn(\"Warning msg\")\n  rospy.logerr(\"Error msg\" )\n  rospy.logfatal(\"Fatal msg\")\n</code></pre></p>"},{"location":"introduction/#rqt_console","title":"rqt_console","text":"<p>GUI for log messages.</p> <pre><code>rqt_console\n</code></pre> <p></p>"},{"location":"introduction/#rqt_plot","title":"rqt_plot","text":"<p>Graphical plot of signals from selected topics.</p> <pre><code>rqt_plot\n</code></pre> <p></p>"},{"location":"introduction/#rqt_graph","title":"rqt_graph","text":"<p>Shows connection between nodes in the system.</p> <pre><code>rqt_graph\n</code></pre> <p></p>"},{"location":"introduction/#rviz","title":"RViz","text":"<p>RViz visually represents data from topics. </p> <p>RViz is NOT a simulation, it represents the current state of the robot</p> <p><pre><code>rosrun rviz rviz\n</code></pre> </p>"},{"location":"practical/","title":"Practical work with robots","text":"<p>Welcome to the practical part of the workshop.</p>"},{"location":"practical/#fe-ros-application-programming-interface","title":"FE ROS Application Programming Interface","text":"<p>We have prepared a couple of helpful methods, classes and scripts to give you a little bit of a head-start with programming the robot motions.</p>"},{"location":"practical/#helpful-motion-methods","title":"Helpful motion methods","text":"<p>In the repository that you have cloned into your workspace there is a package called <code>fe_ros</code>. We provide some helpful Python modules that can be imported into your scripts. One of them is <code>fe_moveit</code>. It's a wrapper around the <code>MoveGroupCommander</code> and using it is fairly easy. Here is an example:</p> <pre><code>#!/usr/bin/env python2\n\n# Import the MoveGroupCommander class from the fe_moveit module\nfrom fe_moveit import MoveGroupCommander\n\n# Create a move group\nmove_group = MoveGroupCommander('manipulator')\n\n# Define a target list in joint space\ntarget_joints = [0, 0, 1.57, 0, 0, 0]\n\n# Send the target to MoveIt and see the robot follow a joint space trajecotry\nmove_group.movej(target=target_joints, wait=True, speed=0.5)\n</code></pre> <p>Naturally, <code>movej</code> is just one of the methods we provide. The following is a full list of the methods we provide for your convenience:</p> <ul> <li><code>movej</code> - Will move the robot in joint space following the trapezoidal speed profile</li> <li><code>movel</code> - Will move the robot to the Cartesian space target following a straight line</li> <li><code>movej_relative</code> - Will move the robot in joint space with an offset to a defined frame</li> <li><code>movel_relative</code> - Will move the robot in Cartesian space following a straight line with an offset to a defined frame.</li> </ul> <p>For a more detailed explanation open the Python module where these methods are defined.</p>"},{"location":"practical/#helpful-stop-service","title":"Helpful stop service","text":"<p>The modified <code>MoveGroupCommander</code> also starts a service that will stop the robot's motion when called. The service is of type <code>std_srv/Empty</code> and is available at <code>/interrupt_motion</code>.</p>"},{"location":"practical/urko_group/urko_task/","title":"Practical task with URKO","text":"<p>The practical task on the URKO robot consists of programming a bin picking and sorting application using a UR10 robot and an advanced 3D camera with localization software.</p> <p>In this document you will find all the information you need to carry out the task.</p>"},{"location":"practical/urko_group/urko_task/#equipment-description-and-connection-suggestion","title":"Equipment description and connection suggestion","text":"<p>The equipment you receive to carry out the application is as follows:</p> <ul> <li>Universal Robots UR10e robot</li> <li>3D camera in the camera-in-hand configuration</li> <li>PickIt machine</li> <li>Vacuum gripper</li> <li>Pressure sensor</li> </ul> <p>A schematics overview of these elements can be seen in the image below:</p> <p></p> <p>Important: The PickIt machine is running ROS core! Therefore, it is important to set up the development computers accordingly!</p> <p>In the next image, we will provide a connectivity overview:</p> <p></p>"},{"location":"practical/urko_group/urko_task/#software-setup","title":"Software setup","text":"<p>PickIt download page</p>"},{"location":"practical/urko_group/urko_task/#task-description","title":"Task description","text":""},{"location":"practical/urko_group/urko_task/#advanced","title":"Advanced","text":"<p>This section of the should be treated as an extra. Tackle it if you were really quick with the main part.</p> <p>Your task is to mix a second item into the bin and program PickIt to detect both items.</p>"},{"location":"simulation/","title":"ROS and simulation","text":""},{"location":"simulation/#gazebo","title":"Gazebo","text":"<p>Gazebo documentation</p> <p>Gazebo tutorials</p> <p>From Gazebo documentation:</p> <ul> <li>Gazebo is a 3D dynamic simulator for simulating robots, environments and sensors.</li> <li>Gazebo offers physics simulation, typicaly much better than simulators in game engines. It supports various physical engines: ODE, Bullet, Simbody, DART.</li> <li>Gazebo is typical used for testing robotics algorithms in realistic scenarios.</li> <li>Gazebo has repository of 3D models: http://models.gazebosim.org/.</li> <li>Gazebo has good support:</li> <li>documentation,</li> <li>tutorials,</li> <li>use cases and examples.</li> </ul> <p>A few key features of Gazebo include:</p> <ul> <li>multiple physics engines,</li> <li>a rich library of robot models and environments,</li> <li>a wide variety of sensors,</li> <li>convenient programmatic and graphical interfaces.</li> </ul> <p>Why use Gazebo? Simulation of robots is fundamental part of developement and testing of applications and algorithms.</p> <p>Gazebo can be run in terminal with command</p> <pre><code>gazebo\n</code></pre> <p>See tutorial http://gazebosim.org/tutorials?tut=quick_start</p>"},{"location":"simulation/#gazebo-gui","title":"Gazebo GUI","text":"<p>https://classic.gazebosim.org/tutorials?cat=guided_b&amp;tut=guided_b2</p>"},{"location":"simulation/#urdf","title":"URDF","text":"<p>URDF, or Unified Robot Description Format, is an XML format used in ROS to describe a robot's physical structure. It includes definitions for robot links and joints, detailing aspects like dimensions, shapes, materials, and the physical constraints between parts. Understanding URDF is crucial because it allows for accurate simulation, visualization, and control of robots in environments like Gazebo and tools like MoveIt!.</p>"},{"location":"simulation/#basic-components-of-urdf","title":"Basic Components of URDF","text":""},{"location":"simulation/#links","title":"Links","text":"<p>Links represent the rigid parts of a robot, such as arms, wheels, or a base. Each link has several attributes that describe its physical properties:</p> <ul> <li>Name: A unique identifier for each link.</li> <li>Inertial Properties: Defines the mass, inertia, and center of mass for accurate physics simulation. This is crucial for ensuring the robot behaves realistically under forces like gravity.</li> <li>Visual Properties: Specifies how the link appears in the simulation. This includes the shape (e.g., box, cylinder, mesh), dimensions, color, and material.</li> <li>Collision Properties: Describes the shape and size used for collision detection in the simulation. It's common to use simplified shapes to reduce computational complexity.</li> </ul> <pre><code>&lt;link name=\"base_link\"&gt;\n  &lt;inertial&gt;\n    &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;\n    &lt;mass value=\"1.0\" /&gt;\n    &lt;inertia ixx=\"0.1\" ixy=\"0.0\" ixz=\"0.0\" iyy=\"0.1\" iyz=\"0.0\" izz=\"0.1\" /&gt;\n  &lt;/inertial&gt;\n  &lt;visual&gt;\n    &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;\n    &lt;geometry&gt;\n      &lt;box size=\"1 1 0.5\" /&gt;\n    &lt;/geometry&gt;\n    &lt;material name=\"blue\"&gt;\n      &lt;color rgba=\"0 0 1 1\" /&gt;\n    &lt;/material&gt;\n  &lt;/visual&gt;\n  &lt;collision&gt;\n    &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;\n    &lt;geometry&gt;\n      &lt;box size=\"1 1 0.5\" /&gt;\n    &lt;/geometry&gt;\n  &lt;/collision&gt;\n&lt;/link&gt;\n</code></pre> <p></p>"},{"location":"simulation/#joints","title":"Joints","text":"<p>Joints define the relationships and movements between two links. Each joint specifies the type of movement allowed (rotational, linear, etc.) and the axis along which this movement occurs:</p> <ul> <li>Name: A unique identifier for each joint.</li> <li>Type: Specifies the joint type (e.g., revolute, prismatic, fixed). The revolute joint allows rotation, while the prismatic joint allows linear movement. Fixed joints do not allow any movement and are used to permanently attach links together.</li> <li>Parent and Child: Defines which links are connected by the joint.</li> <li>Origin: Specifies the position and orientation of the joint relative to the parent link.</li> <li>Axis: For joints that allow movement, this defines the axis along which the motion occurs.</li> </ul> <pre><code>&lt;joint name=\"shoulder_joint\" type=\"revolute\"&gt;\n  &lt;parent link=\"base_link\" /&gt;\n  &lt;child link=\"upper_arm\" /&gt;\n  &lt;origin xyz=\"0 0 0.5\" rpy=\"0 0 0\" /&gt;\n  &lt;axis xyz=\"0 0 1\" /&gt;\n  &lt;limit lower=\"-1.57\" upper=\"1.57\" effort=\"5\" velocity=\"1\" /&gt;\n&lt;/joint&gt;\n</code></pre> <p></p> <p>Basic components of a URDF file are links, joints, and their associated visual and collision models. Properly configured links and joints allow for accurate kinematic chains, which are crucial for realistic simulation and precise control. The visual models ensure that the robot is represented correctly in both simulation and visualization tools, while the collision models optimize interactions with the environment by simplifying complex geometries for efficient physics calculations. </p> <p></p>"},{"location":"simulation/#urdf-and-robot-simulation-in-gazebo","title":"URDF and Robot Simulation in Gazebo","text":"<p>URDF provides a standardized way to describe a robot's physical structure, which Gazebo then uses to create an accurate and realistic simulation of the robot and its interactions with the environment. Gazebo relies on the URDF file to construct an accurate simulation of a robot, including its physical appearance, dynamics, sensors, and control systems. By understanding how to define these elements in URDF and link them to Gazebo plugins, you can create robust simulations that mirror real-world scenarios, providing a valuable environment for testing and development in robotics.</p>"},{"location":"simulation/#how-gazebo-uses-urdf-files","title":"How Gazebo Uses URDF Files","text":"<p>Gazebo utilizes URDF files to create a virtual representation of a robot in the simulation environment. The URDF file provides all the necessary details about the robot's physical components, including:</p> <ul> <li>Geometry and Shape: Defines the robot's physical appearance using basic geometric shapes (like boxes, spheres, and cylinders) or more complex meshes.</li> <li>Inertia and Mass: Specifies the physical properties of each link, such as mass distribution and inertia. These properties are crucial for realistic physical interactions like movement, collisions, and response to forces.</li> <li>Joints and Constraints: Describes how different parts of the robot are connected and the types of movement allowed (e.g., rotational or linear). Gazebo uses this information to simulate the robot's kinematics and dynamics accurately.</li> </ul> <p>Gazebo reads the URDF file to construct a robot model with all these physical and visual properties, which allows for a realistic simulation environment where the robot can move, interact with other objects, and perform tasks as it would in the real world.</p>"},{"location":"simulation/#simulating-physical-interactions","title":"Simulating Physical Interactions","text":"<p>One of the key benefits of using URDF with Gazebo is the ability to simulate realistic physical interactions, which includes:</p> <ul> <li>Collision Detection: Using the collision properties defined in the URDF, Gazebo can detect when the robot's parts come into contact with other objects or surfaces. This is vital for tasks that require interaction with the environment, such as grasping objects or avoiding obstacles.</li> <li>Dynamics and Physics: Gazebo uses the inertial properties from the URDF file to compute how the robot responds to forces, such as gravity, friction, or collisions. This allows the simulation of complex behaviors, such as balancing, jumping, or handling heavy objects.</li> <li>Sensors Simulation: URDF files can also include sensors (e.g., cameras, LIDAR, IMUs) that are essential for perceiving the environment. Gazebo simulates these sensors, providing realistic data that can be used for testing perception algorithms and sensor fusion.</li> </ul>"},{"location":"simulation/#adding-sensors-and-actuators-to-urdf-for-gazebo-simulation","title":"Adding Sensors and Actuators to URDF for Gazebo Simulation","text":"<p>To create a more complete and functional simulation, you can add sensors and actuators directly into the URDF file. This allows Gazebo to simulate not only the robot\u2019s structure but also its ability to perceive and interact with the environment:</p> <ul> <li>Actuators: Motors and servos can also be described in the URDF using the  and  tags. These definitions specify how the joints should be controlled, providing the necessary details for integrating with ROS controllers for movement simulation. <li>Sensors: Sensors like cameras, LIDAR, and ultrasonic sensors can be defined in the URDF file using  tags. These elements provide the simulation parameters for Gazebo to generate realistic sensor data, which can be used in algorithms for object detection, mapping, and navigation. <p>Example URDF Snippet for Sensors:</p> <pre><code>&lt;gazebo&gt;\n  &lt;sensor type=\"camera\" name=\"camera\"&gt;\n    &lt;update_rate&gt;30&lt;/update_rate&gt;\n    &lt;camera&gt;\n      &lt;horizontal_fov&gt;1.047&lt;/horizontal_fov&gt;\n      &lt;image&gt;\n        &lt;width&gt;640&lt;/width&gt;\n        &lt;height&gt;480&lt;/height&gt;\n        &lt;format&gt;R8G8B8&lt;/format&gt;\n      &lt;/image&gt;\n      &lt;clip&gt;\n        &lt;near&gt;0.1&lt;/near&gt;\n        &lt;far&gt;100&lt;/far&gt;\n      &lt;/clip&gt;\n    &lt;/camera&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;\n</code></pre>"},{"location":"simulation/#linking-urdf-to-gazebo-plugins","title":"Linking URDF to Gazebo Plugins","text":"<p>Gazebo plugins extend the functionality of the simulation by providing additional capabilities, such as custom sensor models, advanced control strategies, or environmental interactions. These plugins can be linked to a URDF file to enhance the simulation:</p> <ul> <li>Adding Plugins in URDF: Plugins are defined within the URDF file using  tags. This allows you to customize the robot's behavior in the simulation beyond the basic physical properties described by URDF. <li>Types of Plugins: Common plugins include those for differential drive (for wheeled robots), grippers (for manipulation tasks), or custom sensor behavior (for specialized sensors not natively supported by Gazebo).</li> <pre><code>&lt;gazebo&gt;\n  &lt;plugin name=\"differential_drive_controller\" filename=\"libgazebo_ros_diff_drive.so\"&gt;\n    &lt;ros&gt;\n      &lt;namespace&gt;/robot&lt;/namespace&gt;\n      &lt;remapping&gt;&lt;remap from=\"odom\" to=\"/odom\" /&gt;&lt;/remapping&gt;\n    &lt;/ros&gt;\n    &lt;left_joint&gt;left_wheel_joint&lt;/left_joint&gt;\n    &lt;right_joint&gt;right_wheel_joint&lt;/right_joint&gt;\n    &lt;updateRate&gt;50&lt;/updateRate&gt;\n  &lt;/plugin&gt;\n&lt;/gazebo&gt;\n</code></pre>"},{"location":"simulation/#integrating-urdf-with-ros-control-and-moveit","title":"Integrating URDF with ROS Control and MoveIt!","text":""},{"location":"simulation/#using-urdf-with-ros-control","title":"Using URDF with ROS Control","text":"<p>URDF files are fundamental to ROS Control as they provide detailed descriptions of the robot's kinematic structure and dynamics, which are crucial for setting up controllers. Here\u2019s how URDF integrates with ROS Control:</p> <ul> <li>Joint and Link Definitions: URDF specifies all the joints and links in a robot, including their kinematic relationships and dynamics. ROS Control uses this information to understand how the joints move and interact.</li> <li>Transmission Elements: URDF includes  tags that define how joint states (e.g., position, velocity) are converted into actuator commands and vice versa. These transmissions are critical for interfacing the robot hardware or simulation with ROS controllers. <li>Controller Configuration: Using the URDF definitions, ROS Control allows configuring different types of controllers (e.g., position, velocity, effort) for the robot joints. The controller configuration is typically defined in YAML files that reference joint names from the URDF.</li> <p>Example URDF Snippet for Transmission:</p> <pre><code>&lt;transmission name=\"shoulder_trans\"&gt;\n  &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;\n  &lt;joint name=\"shoulder_joint\"&gt;\n    &lt;hardwareInterface&gt;hardware_interface/EffortJointInterface&lt;/hardwareInterface&gt;\n  &lt;/joint&gt;\n  &lt;actuator name=\"shoulder_motor\"&gt;\n    &lt;mechanicalReduction&gt;50&lt;/mechanicalReduction&gt;\n  &lt;/actuator&gt;\n&lt;/transmission&gt;\n</code></pre>"},{"location":"simulation/#setting-up-controllers-using-urdf-and-ros-control","title":"Setting Up Controllers Using URDF and ROS Control","text":"<p>Once the URDF file is defined with joints and transmissions, ROS Control requires additional configuration to set up controllers:</p> <ul> <li>Controller Manager: ROS Control uses a controller manager to load, unload, start, and stop controllers dynamically. The manager reads the URDF to understand the robot's structure and uses this information to allocate controllers.</li> <li>Loading Controllers: Controllers are loaded using configuration files (typically in YAML format) that reference the URDF-defined joints and specify the type of control (e.g., position, velocity, effort). These configurations map directly to the joints defined in the URDF file.</li> </ul> <p>Example YAML Configuration for ROS Control:</p> <pre><code>controller_manager:\n  ros__parameters:\n    update_rate: 100\n\nmy_position_controller:\n  type: joint_trajectory_controller/JointTrajectoryController\n  joints:\n    - shoulder_joint\n    - elbow_joint\n  constraints:\n    goal_time: 0.5\n  state_publish_rate: 50\n  action_monitor_rate: 10\n  stop_trajectory_duration: 0.5\n</code></pre>"},{"location":"simulation/#2-dof-robot-visualization","title":"2 DOF robot visualization","text":"<p>Lets first create a new catkin workspace.</p> <pre><code>mkdir catkin_ws\ncd catkin_ws\nmkdir src\ncatkin_make\nsource devel/setup.bash\n</code></pre> <p>Lets create new package for simple 2 DOF robot.</p> <pre><code>cd src\ncatkin_create_pkg robot_2dof roscpp rospy std_msgs\n</code></pre> <p>We will create 2 folders:</p> <ul> <li>folder <code>urdf</code> for storing urdf files and</li> <li>folder <code>launch</code> for launch files.</li> </ul> <pre><code>cd robot_2dof\nmkdir urdf\nmkdir launch\ncd ../..\ncatkin_make\n</code></pre> <p>Check if required packages are installed with command</p> <pre><code>rospack list-names\n</code></pre> <p>We will require packages</p> <pre><code>urdf_tutorial\nrobot_state_publisher\njoint_state_controller\njoint_state_publisher_gui\n</code></pre> <p>We will create urdf file for 2 DOF robot. Move into catkin workspace folder and then into <code>urdf</code> folder.</p> <pre><code>cd src/robot_2dof/urdf/\n</code></pre> <p>Create urdf file and open it in editor.</p> <pre><code>touch robot2dof.urdf\ncode robot2dof.urdf\n</code></pre> <p>Copy the code into urdf file.</p> <pre><code>&lt;?xml version=\"1\"?&gt;\n&lt;robot name=\"2dof_robot\"&gt;\n\n    &lt;material name=\"White\"&gt;\n        &lt;color rgba=\"1.0 1.0 1.0 1.0\"/&gt;\n    &lt;/material&gt;\n\n    &lt;material name=\"Blue\"&gt;\n        &lt;color rgba=\"0.0 0.0 1.0 1.0\"/&gt;\n    &lt;/material&gt; \n\n    &lt;material name=\"Red\"&gt;\n        &lt;color rgba=\"1 0 0 1.0\"/&gt;\n    &lt;/material&gt;\n\n    &lt;material name=\"Black\"&gt;\n        &lt;color rgba=\"0 0 0 1.0\"/&gt;\n    &lt;/material&gt;    \n\n   &lt;link name=\"world\"/&gt;\n\n   &lt;!-- BASE LINK--&gt;\n    &lt;link name=\"base_link\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.16 0.16 1.0\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"White\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.16 0.16 1.0\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"fixed_base\" type=\"fixed\"&gt;\n        &lt;parent link=\"world\"/&gt;\n        &lt;child link=\"base_link\"/&gt;\n    &lt;/joint&gt;\n\n    &lt;!-- PRVI SEGMENT--&gt;\n    &lt;link name=\"prvi_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Red\"/&gt;\n            &lt;origin xyz=\"0.12 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"prvi_sklep\" type=\"continuous\"&gt;\n        &lt;axis xyz=\"1 0 0\"/&gt;\n        &lt;parent link=\"base_link\"/&gt;\n        &lt;child link=\"prvi_segment\"/&gt;\n        &lt;origin xyz=\"0.0 0 0.92\" rpy=\"-1.5707 0 0\"/&gt;\n    &lt;/joint&gt;\n\n     &lt;!-- DRUGI SEGMENT--&gt;\n    &lt;link name=\"drugi_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Blue\"/&gt;\n            &lt;origin xyz=\"-0.08 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"drugi_sklep\" type=\"continuous\"&gt;\n        &lt;axis xyz=\"1 0 0\"/&gt;\n        &lt;parent link=\"prvi_segment\"/&gt;\n        &lt;child link=\"drugi_segment\"/&gt;\n        &lt;origin xyz=\"0.12 0 0.42\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n\n        &lt;!-- TCP SEGMENT--&gt;\n    &lt;link name=\"TCP_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"0.02\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Red\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"0.02\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"TCP_sklep\" type=\"fixed\"&gt;\n        &lt;parent link=\"drugi_segment\"/&gt;\n        &lt;child link=\"TCP_segment\"/&gt;\n        &lt;origin xyz=\"-0.08 0 0.46\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n\n&lt;/robot&gt;\n</code></pre> <p>We can visualize the model in rviz with command.</p> <pre><code>roslaunch urdf_tutorial display.launch model:='$(find robot_2dof)/urdf/robot2dof.urdf'\n</code></pre> <p></p> <p>In new terminal window we can list all the ROS topics with command</p> <pre><code>rostopic list\n</code></pre> <p>We receive output</p> <pre><code>/clicked_point\n/initialpose\n/joint_states\n/move_base_simple/goal\n/rosout\n/rosout_agg\n/tf\n/tf_static\n</code></pre> <p>We can print the values of the joints in terminal window with command</p> <pre><code>rostopic echo /joint_states\n</code></pre> <p>Now if we change the values using slider on the GUI we can follow the values of joints.</p>"},{"location":"simulation/#visualization-of-franka-panda-robot","title":"Visualization of Franka Panda robot","text":"<p>We will now visualize more complex model of the robot, such as Franka Panda robot.</p> <p>Copy file franka_description.zip into folder <code>src</code> and unzip it.</p> <p>Run command</p> <pre><code>cd src\ncatkin_create_pkg franka_description\ncd ../..\ncatkin_make\n</code></pre> <pre><code>roslaunch urdf_tutorial display.launch model:='$(find franka_description)/urdf/panda.urdf'\n</code></pre> <p>In rviz you need to change Fixed Frame (in Global Options) to panda_link0.</p>"},{"location":"simulation/#importing-2-dof-robot-in-gazebo","title":"Importing 2 DOF robot in gazebo","text":"<p>First, we will create launch file to load urdf file into gazebo. Go to <code>launch</code> folder:</p> <pre><code>touch zagon_gazebo.launch\ncode zagon_gazebo.launch\n</code></pre> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n&lt;launch&gt;\n\n    &lt;param name=\"robot_description\" textfile=\"$(find robot_2dof)/urdf/robot2dof.urdf\" /&gt;\n    &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\" /&gt;\n\n    &lt;node pkg=\"gazebo_ros\" name=\"spawn_urdf\" type=\"spawn_model\" args=\"-param robot_description -urdf -model robot2dof\" /&gt;\n\n    &lt;!-- --&gt;\n\n&lt;/launch&gt;\n</code></pre> <p>We can run the launch file with command</p> <pre><code>roslaunch robot_2dof zagon_gazebo.launch\n</code></pre> <p>What we see is only empty gazebo world without the robot. This is because the urdf file does not contain everything we need for simulation in gazebo. First, we need to add <code>&lt;inertial&gt;</code> tag to each link. Gazebo uses physics engine and needs information about ineratial properties of the bodies, including links (documentation) of the robots. If <code>&lt;inertial&gt;</code> property is not added to the link or mass is zero, Gazebo will ignore the link. It is also quite important for stable physical simulation that inertial parameters are quite accurate or at least have reasonable values.</p> <p>Below is urdf file with added inertial parameters for each link.</p> <pre><code>&lt;?xml version=\"1\"?&gt;\n&lt;robot name=\"2dof_robot\"&gt;\n\n    &lt;material name=\"White\"&gt;\n        &lt;color rgba=\"1.0 1.0 1.0 1.0\"/&gt;\n    &lt;/material&gt;\n\n    &lt;material name=\"Blue\"&gt;\n        &lt;color rgba=\"0.0 0.0 1.0 1.0\"/&gt;\n    &lt;/material&gt; \n\n    &lt;material name=\"Red\"&gt;\n        &lt;color rgba=\"1 0 0 1.0\"/&gt;\n    &lt;/material&gt;\n\n    &lt;material name=\"Black\"&gt;\n        &lt;color rgba=\"0 0 0 1.0\"/&gt;\n    &lt;/material&gt;    \n\n   &lt;link name=\"world\"/&gt;\n\n   &lt;!-- BASE LINK--&gt;\n    &lt;link name=\"base_link\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.16 0.16 1.0\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"White\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.16 0.16 1.0\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"25\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\"/&gt;\n            &lt;inertia ixx=\"8.741\" iyy=\"8.741\" izz=\"0.4367\" ixy=\"-0.1637\" ixz=\"-0.1023\"  iyz=\"-0.1023\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"fixed_base\" type=\"fixed\"&gt;\n        &lt;parent link=\"world\"/&gt;\n        &lt;child link=\"base_link\"/&gt;\n    &lt;/joint&gt;\n\n    &lt;!-- PRVI SEGMENT--&gt;\n    &lt;link name=\"prvi_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Red\"/&gt;\n            &lt;origin xyz=\"0.12 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"2.5\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.25\"/&gt;\n            &lt;inertia ixx=\"0.2091\" iyy=\"0.2091\" izz=\"0.002\" ixy=\"0.0\" ixz=\"0.0\"  iyz=\"0.0\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"prvi_sklep\" type=\"continuous\"&gt;\n        &lt;axis xyz=\"1 0 0\"/&gt;\n        &lt;parent link=\"base_link\"/&gt;\n        &lt;child link=\"prvi_segment\"/&gt;\n        &lt;origin xyz=\"0.0 0 0.92\" rpy=\"-1.5707 0 0\"/&gt;\n    &lt;/joint&gt;\n\n     &lt;!-- DRUGI SEGMENT--&gt;\n    &lt;link name=\"drugi_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Blue\"/&gt;\n            &lt;origin xyz=\"-0.08 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"2.5\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.25\"/&gt;\n            &lt;inertia ixx=\"0.2091\" iyy=\"0.2091\" izz=\"0.002\" ixy=\"0.0\" ixz=\"0.0\"  iyz=\"0.0\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"drugi_sklep\" type=\"continuous\"&gt;\n        &lt;axis xyz=\"1 0 0\"/&gt;\n        &lt;parent link=\"prvi_segment\"/&gt;\n        &lt;child link=\"drugi_segment\"/&gt;\n        &lt;origin xyz=\"0.12 0 0.42\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n\n        &lt;!-- TCP SEGMENT--&gt;\n    &lt;link name=\"TCP_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"0.02\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Red\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"0.02\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"0.034\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\"/&gt;\n            &lt;inertia ixx=\"0.0000054\" iyy=\"0.0000054\" izz=\"0.0000054\" ixy=\"0.0\" ixz=\"0.0\"  iyz=\"0.0\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"TCP_sklep\" type=\"fixed\"&gt;\n        &lt;parent link=\"drugi_segment\"/&gt;\n        &lt;child link=\"TCP_segment\"/&gt;\n        &lt;origin xyz=\"-0.08 0 0.46\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n\n&lt;/robot&gt;\n</code></pre> <p>Simulation starts and the robot acts as 2 DOF pendulum. We can add a pause argument in lauch file, so that the simulation does not run automatically.</p> <pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n&lt;launch&gt;\n\n    &lt;arg name=\"paused\" default=\"true\"/&gt;\n\n    &lt;param name=\"robot_description\" textfile=\"$(find robot_2dof)/urdf/robot2dof.urdf\" /&gt;\n    &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n        &lt;arg name=\"paused\" value=\"$(arg paused)\"/&gt;\n    &lt;/include&gt;    \n\n    &lt;node pkg=\"gazebo_ros\" name=\"spawn_urdf\" type=\"spawn_model\" args=\"-param robot_description -urdf -model robot2dof\" /&gt;\n\n    &lt;!-- --&gt;\n\n&lt;/launch&gt;\n</code></pre> <p>We see a robot, but it is essentially nonfunctional gazebo interface. It doesn't do anything, and is missing lots of key information that ROS would need to use this robot. Whe we started visualization with urdf_tutorial we had been using joint_state_publisher to specify the pose of each joint. However, the robot itself should provide that information in the real world or in gazebo. Yet without specifying that, Gazebo doesn't know to publish that information. To achieve this and for the robot to be interactive with ROS, we need to specify Plugins and Transmissions.</p>"},{"location":"simulation/#gazebo-plugin","title":"Gazebo plugin","text":"<p>Gazebo plugin is needed for proper interaction between ROS and Gazebo. We need to dynamically link to the ROS library by adding <code>&lt;gazebo&gt;</code> tag before the closing <code>&lt;/robot&gt;</code> tag:</p> <pre><code>    &lt;gazebo&gt;\n        &lt;plugin name=\"control\" filename=\"libgazebo_ros_control.so\"&gt;\n            &lt;robotNamespace&gt;/MOJROBOT&lt;/robotNamespace&gt;\n        &lt;/plugin&gt;\n    &lt;/gazebo&gt; \n</code></pre>"},{"location":"simulation/#transmission","title":"Transmission","text":"<p>For every joint we need to specify a transmission. Transmission declares how the joint will be driven or controlled. There are three types of transmissions (documentation):</p> <ul> <li>positional - PositionJointInterface,</li> <li>velocity - VelocityJointInterface,</li> <li>joint torque - EffortJointInterface.</li> </ul> <p>Before the closing <code>&lt;/robot&gt;</code> tag add the following code:</p> <pre><code>    &lt;!-- PRENOSI --&gt;\n    &lt;transmission name=\"trans1\"&gt;\n        &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;\n        &lt;joint name=\"prvi_sklep\"&gt;\n            &lt;hardwareInterface&gt;hardware_interface/PositionJointInterface&lt;/hardwareInterface&gt;\n        &lt;/joint&gt;\n        &lt;actuator name=\"motor1\"&gt;\n            &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;\n        &lt;/actuator&gt;\n    &lt;/transmission&gt;\n\n    &lt;transmission name=\"trans2\"&gt;\n        &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;\n        &lt;joint name=\"drugi_sklep\"&gt;\n            &lt;hardwareInterface&gt;hardware_interface/PositionJointInterface&lt;/hardwareInterface&gt;\n        &lt;/joint&gt;\n        &lt;actuator name=\"motor2\"&gt;\n            &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;\n        &lt;/actuator&gt;\n    &lt;/transmission&gt;\n</code></pre>"},{"location":"simulation/#controlling-the-2dof-robot","title":"Controlling the 2DOF robot","text":"<p>Now that we linked Gazebo and ROS we want to control the robot. We have to setup the controllers.</p> <p>First we need to add <code>joint_state_publisher</code> gazebo plugin in <code>urdf</code> file:</p> <pre><code>    &lt;gazebo&gt;\n        &lt;plugin name=\"joint_state_publisher\" filename=\"libgazebo_ros_joint_state_publisher.so\"&gt;\n            &lt;jointName&gt;prvi_sklep, drugi_sklep&lt;/jointName&gt;\n        &lt;/plugin&gt;\n    &lt;/gazebo&gt; \n</code></pre> <p>We need to create <code>yaml</code> files with specifications for controllers. <code>yaml</code> will be saved in <code>config</code> folder. Lets move into our <code>src</code> folder of our workspace.</p> <p>We will create 1 folder:</p> <ul> <li>folder <code>config</code> for storing  <code>yaml</code> files.</li> </ul> <pre><code>cd robot_2dof\nmkdir config\ncd config\n</code></pre> <p>Create <code>yaml</code>  file and open it in editor.</p> <pre><code>touch controller.yaml\ncode controller.yaml\n</code></pre> <p>Add the following text:</p> <pre><code>MOJROBOT:\n  # publish all joint states:\n  joint_state_controller:\n    type: joint_state_controller/JointStateController\n    publish_rate: 10\n\nMOJROBOT/gazebo_ros_control/pid_gains:\n  prvi_sklep: {p: 1000, i: 0,  d: 100}\n  drugi_sklep: {p: 1000, i: 0,  d: 100}\n</code></pre> <p>In <code>launch</code> file we need to add the following lines:</p> <pre><code>    &lt;rosparam file=\"$(find robot_2dof)/config/controller.yaml\" command=\"load\"/&gt;\n\n    &lt;node name=\"controller_spawner\" pkg=\"controller_manager\" type=\"spawner\" respawn=\"false\" output=\"screen\" ns=\"/MOJROBOT\" \n        args=\"joint_state_controller\"/&gt;\n\n    &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" respawn=\"false\" output=\"screen\"&gt;\n        &lt;remap from=\"/joint_states\" to=\"/MOJROBOT/joint_states\" /&gt;\n    &lt;/node&gt;\n</code></pre> <p>Run the launc file <code>roslaunch robot_2dof zagon_gazebo.launch</code>.</p> <p>Now we can observe the joint angles. Type into terminal window command <code>rostopic list</code>, we get the list of topics</p> <pre><code>/MOJROBOT/gazebo_ros_control/pid_gains/drugi_sklep/parameter_descriptions\n/MOJROBOT/gazebo_ros_control/pid_gains/drugi_sklep/parameter_updates\n/MOJROBOT/gazebo_ros_control/pid_gains/prvi_sklep/parameter_descriptions\n/MOJROBOT/gazebo_ros_control/pid_gains/prvi_sklep/parameter_updates\n/MOJROBOT/joint_states\n/clock\n/gazebo/link_states\n/gazebo/model_states\n/gazebo/parameter_descriptions\n/gazebo/parameter_updates\n/gazebo/set_link_state\n/gazebo/set_model_state\n/joint_states\n/rosout\n/rosout_agg\n/tf\n/tf_static\n</code></pre> <p>Run command <code>rostopic echo /MOJROBOT/joint_states</code> and you can now track joint angles.</p> <p>However, we want not just observe joint angles, but also control the robot. We need to add the controller for the individual joints. We will do that by adding joint controller <code>joint_controller</code>. We will first add it to <code>launch</code> file to the <code>controller_spawner</code>:</p> <pre><code>    &lt;node name=\"controller_spawner\" pkg=\"controller_manager\" type=\"spawner\" respawn=\"false\" output=\"screen\" ns=\"/MOJROBOT\" \n        args=\"joint_state_controller\n        joint_controller\"/&gt; &lt;!--Add this new line--&gt;\n</code></pre> <p>Next we need to add it to the <code>yaml</code> file:</p> <pre><code>MOJROBOT:\n  # publish all joint states:\n  joint_state_controller:\n    type: joint_state_controller/JointStateController\n    publish_rate: 10\n  joint_controller: #Add this new line\n    type: position_controllers/JointTrajectoryController #Add this new line\n    joints: #Add this new line\n    - prvi_sklep #Add this new line\n    - drugi_sklep #Add this new line\n</code></pre> <p>Now when we run the launch file, we get new rostopics:</p> <pre><code>/MOJROBOT/joint_controller/command\n/MOJROBOT/joint_controller/follow_joint_trajectory/cancel\n/MOJROBOT/joint_controller/follow_joint_trajectory/feedback\n/MOJROBOT/joint_controller/follow_joint_trajectory/goal\n/MOJROBOT/joint_controller/follow_joint_trajectory/result\n/MOJROBOT/joint_controller/follow_joint_trajectory/status\n/MOJROBOT/joint_controller/state\n</code></pre> <p>If we type command <code>rostopic info /MOJROBOT/joint_controller/command</code> we can see which type of message we need to publish to control the robot joints:</p> <pre><code>Type: trajectory_msgs/JointTrajectory\n\nPublishers: None\n\nSubscribers: \n * /gazebo (http://lr-omen:35047/)\n</code></pre> <p>To move the robot we need to publish the following message:</p> <pre><code>rostopic pub /MOJROBOT/joint_controller/command trajectory_msgs/JointTrajectory '{joint_names:[\"prvi_sklep\",\"drugi_sklep\"],points:[{positions:[-0.5, 0.2], time_from_start:[1,0]}]}'\n</code></pre> <p>The full files content of the files until this point is linked bellow.</p>"},{"location":"simulation/#controlling-the-2dof-robot-using-moveit","title":"Controlling the 2DOF robot using MoveIt","text":"<p>The aim of this section is to use MoveIt package to send the commands to the Gazebo simulation of the robot. Full documentation for MoveIt is http://docs.ros.org/en/melodic/api/moveit_tutorials/html/index.html. We will use MoveIt Setup Assistant to create MoveIt configuration for our 2DOF robot. We will closely follow the tutorial published on MoveIt page. Here we will give really short overview.</p> <p>In terminal run command <code>roslaunch moveit_setup_assistant setup_assistant.launch</code>.</p> <ol> <li> <p>In Start tab select Create New MoveIt Configuration Package and browse for <code>robot2dof.urdf</code> file. Load the file.    </p> </li> <li> <p>Self-Collisins tab.  Click on the Generate Collision Matrix button   </p> </li> <li> <p>Planning groups tab. Clock on Click on Add Group. You will be presented by new window.</p> </li> <li>Enter Group Name as arm.</li> <li>Choose kdl_kinematics_plugin/KDLKinematicsPlugin as the kinematics solver.</li> <li> <p>Click on the Add Joints button. You will bepresented by new window. Choose the appropriate joints. See figure bellow. Click Save.     </p> </li> <li> <p>Next figure shows most basic definition for the 2DOF robot.     </p> </li> <li> <p>End Effectors tab. Click Add End Effector. You will be presented by new window.</p> </li> <li>Choose TCP as the End Effector Name.</li> <li> <p>Choose TCP_segment as the Parent Link for this end-effector. Click Save.      </p> </li> <li> <p>ROS Control tab. Click on Add Controller. Add MOJROBOT/arm_controller for Controller Name and choose controller type. See figure bellow. Click Save . You might get error Invalid ROS controller name. If you get the error close the error dialog. Click the button Auto Add FollowJointsTrajectory Controllers For Each Planning Group*. We will add the correct controller manually later.      </p> </li> <li> <p>Author Information tab. Enter your name and email address.</p> </li> <li>Configuration Files tab. Create folder <code>robot_2dof_moveit_config</code> in <code>src</code> folder of your workspace. Browse for that folder and click Generate Package button. The Setup Assistant will now generate and write a set of launch and config files.     </li> </ol> <p>Now that we have created the MoveIt configuration files, we need to edit them so that they can be used with Gazebo. The auto-generated launch and config files are not ready for use in Gazebo. If you run command in terminal <code>roslaunch robot_2dof_moveit_config demo_gazebo.launch</code> you will se that in rviz you can plan movement, but when you want to execurte them the robot in Gazebo does not move. MoveIt generates the file <code>ros_controllers.yaml</code> which is missing definition for <code>controller_list</code>. We also need to add the namespace for our robot. The required steps are:</p> <ol> <li>File <code>ros_controllers.yaml</code>. Add definition for namespace and controller list.</li> </ol> <pre><code># Publish all joint states\n# Creates the /joint_states topic necessary in ROS\nMOJROBOT:\n  joint_state_controller:\n    type: joint_state_controller/JointStateController\n    publish_rate: 50\n  arm_controller:\n    type: position_controllers/JointTrajectoryController\n    joints:\n      - prvi_sklep\n      - drugi_sklep\n    gains:\n      prvi_sklep:\n        p: 100\n        d: 1\n        i: 1\n        i_clamp: 1\n      drugi_sklep:\n        p: 100\n        d: 1\n        i: 1\n        i_clamp: 1\n\ncontroller_list:\n  - name: MOJROBOT/arm_controller\n    action_ns: follow_joint_trajectory\n    type: FollowJointTrajectory\n    default: true\n    joints:\n      - prvi_sklep\n      - drugi_sklep  \n</code></pre> <ol> <li>File <code>ros_controllers.launch</code>. This launch file loads Gazebo controllers. We need to add additional controllers to <code>controller_spawner</code> node:</li> </ol> <pre><code>  &lt;!-- Load the controllers --&gt;\n  &lt;node name=\"controller_spawner\" pkg=\"controller_manager\" type=\"spawner\" respawn=\"false\"\n    output=\"screen\" args=\"--namespace=/MOJROBOT\n    joint_state_controller\n    arm_controller\n    --timeout 20\"/&gt;\n</code></pre> <ol> <li> <p>File <code>demo_gazebo.launch</code>. Definition for node <code>joint_state_publisher</code> has to be changed. Also for <code>rosparam</code> <code>source_list</code> you need to add correct namespace. Replace the following lines</p> <pre><code>&lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\" unless=\"$(arg use_gui)\"&gt;\n    &lt;rosparam param=\"source_list\"&gt;[move_group/fake_controller_joint_states]&lt;/rosparam&gt;\n    &lt;rosparam param=\"source_list\"&gt;[joint_states]&lt;/rosparam&gt;\n&lt;/node&gt;\n&lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher_gui\" type=\"joint_state_publisher_gui\" if=\"$(arg use_gui)\"&gt;\n    &lt;rosparam param=\"source_list\"&gt;[move_group/fake_controller_joint_states]&lt;/rosparam&gt;\n    &lt;rosparam param=\"source_list\"&gt;[joint_states]&lt;/rosparam&gt;\n    &lt;/node&gt;\n</code></pre> <p>with</p> <pre><code>&lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\"&gt;\n    &lt;param name=\"use_gui\" value=\"$(arg use_gui)\"/&gt;\n    &lt;rosparam param=\"source_list\"&gt;[MOJROBOT/joint_states]&lt;/rosparam&gt;\n&lt;/node&gt;\n</code></pre> </li> </ol> <p>The full files content of the files until this point is linked bellow.</p> <p>A relatively short explanation of the above process can be found on https://medium.com/@tahsincankose/custom-manipulator-simulation-in-gazebo-and-motion-planning-with-moveit-c017eef1ea90</p> <p>Now when you run command <code>roslaunch robot_2dof_moveit_config demo_gazebo.launch</code> you can move robot in Gazebo.</p> <p></p>"},{"location":"simulation/#sensors","title":"Sensors","text":"<p>We can add various sensors to the robot in <code>urdf</code> file. Typically we need to create a link for the sensor and a fixed joint to add the link to the link of the robot. Finally we add <code>gazebo</code> and <code>sensor</code> tag with appropriate <code>plugin</code> and parameters for the sensor.</p>"},{"location":"simulation/#camera-sensor","title":"Camera sensor","text":"<p>First we add a link and a joint for the camera sensor in the <code>urdf</code> file for the robot.</p> <pre><code>    &lt;link name=\"camera_link\"&gt;\n        &lt;visual&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\"/&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.05 0.05 0.05\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Black\"/&gt;\n        &lt;/visual&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"1e-5\" /&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\"/&gt;\n            &lt;inertia ixx=\"1e-6\" ixy=\"0\" ixz=\"0\" iyy=\"1e-6\" iyz=\"0\" izz=\"1e-6\" /&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;   \n\n    &lt;joint name=\"camera_joint\" type=\"fixed\"&gt;\n        &lt;origin xyz=\"0.0 0.0 0.06\" rpy=\"0 0 0\"/&gt;\n        &lt;parent link=\"TCP_segment\"/&gt;\n        &lt;child link=\"camera_link\"/&gt;\n    &lt;/joint&gt;\n</code></pre> <p>Next we add the plugin and input camera parameters.</p> <pre><code>    &lt;!-- camera --&gt;\n    &lt;gazebo reference=\"camera_link\"&gt;\n    &lt;material&gt;Gazebo/Black&lt;/material&gt;\n        &lt;sensor type=\"camera\" name=\"camera1\"&gt;\n            &lt;update_rate&gt;30.0&lt;/update_rate&gt;\n            &lt;camera name=\"head\"&gt;\n                &lt;horizontal_fov&gt;1.3962634&lt;/horizontal_fov&gt;\n                &lt;image&gt;\n                    &lt;width&gt;800&lt;/width&gt;\n                    &lt;height&gt;800&lt;/height&gt;\n                    &lt;format&gt;R8G8B8&lt;/format&gt;\n                &lt;/image&gt;\n                &lt;clip&gt;\n                    &lt;near&gt;0.02&lt;/near&gt;\n                    &lt;far&gt;300&lt;/far&gt;\n                &lt;/clip&gt;\n                &lt;noise&gt;\n                    &lt;type&gt;gaussian&lt;/type&gt;\n                    &lt;mean&gt;0.0&lt;/mean&gt;\n                    &lt;stddev&gt;0.007&lt;/stddev&gt;\n                &lt;/noise&gt;\n            &lt;/camera&gt;\n            &lt;plugin name=\"camera_controller\" filename=\"libgazebo_ros_camera.so\"&gt;\n                &lt;alwaysOn&gt;true&lt;/alwaysOn&gt;\n                &lt;updateRate&gt;0.0&lt;/updateRate&gt;\n                &lt;cameraName&gt;robot_2dof/camera1&lt;/cameraName&gt;\n                &lt;imageTopicName&gt;image_raw&lt;/imageTopicName&gt;\n                &lt;cameraInfoTopicName&gt;camera_info&lt;/cameraInfoTopicName&gt;\n                &lt;frameName&gt;camera_link&lt;/frameName&gt;\n                &lt;hackBaseline&gt;0.07&lt;/hackBaseline&gt;\n                &lt;distortionK1&gt;0.0&lt;/distortionK1&gt;\n                &lt;distortionK2&gt;0.0&lt;/distortionK2&gt;\n                &lt;distortionK3&gt;0.0&lt;/distortionK3&gt;\n                &lt;distortionT1&gt;0.0&lt;/distortionT1&gt;\n                &lt;distortionT2&gt;0.0&lt;/distortionT2&gt;\n            &lt;/plugin&gt;\n        &lt;/sensor&gt;\n    &lt;/gazebo&gt; \n</code></pre>"},{"location":"simulation/#laser-sensor","title":"Laser sensor","text":"<p>First we add a link and a joint for the laser sensor in the <code>urdf</code> file for the robot.</p> <pre><code>    &lt;!-- Sick Laser --&gt;\n    &lt;link name=\"sick_link\"&gt;\n        &lt;collision&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\"/&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.1 0.1 0.1\"/&gt;\n            &lt;/geometry&gt;\n        &lt;/collision&gt;\n\n        &lt;visual&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\"/&gt;\n            &lt;geometry&gt;\n                &lt;!--&lt;mesh filename=\"package://rrbot_description/meshes/hokuyo.dae\"/&gt;--&gt;\n                &lt;box size=\"0.1 0.1 0.1\"/&gt;\n            &lt;/geometry&gt;\n        &lt;/visual&gt;\n\n        &lt;inertial&gt;\n            &lt;mass value=\"1e-5\" /&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\"/&gt;\n            &lt;inertia ixx=\"1e-6\" ixy=\"0\" ixz=\"0\" iyy=\"1e-6\" iyz=\"0\" izz=\"1e-6\" /&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"sick_joint\" type=\"fixed\"&gt;\n        &lt;axis xyz=\"0 1 0\" /&gt;\n        &lt;origin xyz=\"0 0.5 0.2\" rpy=\"0 0 0\"/&gt;\n        &lt;parent link=\"world\"/&gt;\n        &lt;!--&lt;parent link=\"TCP_segment\"/&gt;--&gt;\n        &lt;child link=\"sick_link\"/&gt;\n    &lt;/joint&gt;    \n</code></pre> <p>Next we add the plugin and input sensor parameters.</p> <pre><code>    &lt;!-- sick --&gt;\n    &lt;gazebo reference=\"sick_link\"&gt;\n        &lt;sensor type=\"ray\" name=\"head_sick_sensor\"&gt;\n            &lt;pose&gt;0 0 0 0 0 0&lt;/pose&gt;\n            &lt;visualize&gt;true&lt;/visualize&gt;\n            &lt;update_rate&gt;40&lt;/update_rate&gt;\n            &lt;ray&gt;\n                &lt;scan&gt;\n                    &lt;horizontal&gt;\n                        &lt;samples&gt;720&lt;/samples&gt;\n                        &lt;resolution&gt;1&lt;/resolution&gt;\n                        &lt;min_angle&gt;-1.570796&lt;/min_angle&gt;\n                        &lt;max_angle&gt;1.570796&lt;/max_angle&gt;\n                    &lt;/horizontal&gt;\n                &lt;/scan&gt;\n                &lt;range&gt;\n                    &lt;min&gt;0.10&lt;/min&gt;\n                    &lt;max&gt;30.0&lt;/max&gt;\n                    &lt;resolution&gt;0.01&lt;/resolution&gt;\n                &lt;/range&gt;\n                &lt;noise&gt;\n                    &lt;type&gt;gaussian&lt;/type&gt;\n                    &lt;!-- Noise parameters based on published spec for Hokuyo laser\n                    achieving \"+-30mm\" accuracy at range &lt; 10m.  A mean of 0.0m and\n                    stddev of 0.01m will put 99.7% of samples within 0.03m of the true\n                    reading. --&gt;\n                    &lt;mean&gt;0.0&lt;/mean&gt;\n                    &lt;stddev&gt;0.01&lt;/stddev&gt;\n                &lt;/noise&gt;\n            &lt;/ray&gt;\n            &lt;plugin name=\"gazebo_ros_head_sick_controller\" filename=\"libgazebo_ros_laser.so\"&gt;\n                &lt;topicName&gt;/robot_2dof/laser/scan&lt;/topicName&gt;\n                &lt;frameName&gt;sick_link&lt;/frameName&gt;\n            &lt;/plugin&gt;\n        &lt;/sensor&gt;\n    &lt;/gazebo&gt;\n</code></pre>"},{"location":"simulation/#warehouse-environment","title":"Warehouse environment","text":"<p>We will add the model for warehouse environment.</p> <p>Copy file warehouse.zip into folder <code>robot_2dof_moveit_config</code> and unzip it. You must unzip it directly into folder <code>robot_2dof_moveit_config</code> so that the folder contains new folders <code>worlds</code>, <code>meshes</code> and <code>models</code>.</p> <p>In <code>gazebo.launch</code> change the line</p> <pre><code>    &lt;arg name=\"world_name\" default=\"worlds/empty.world\"/&gt;\n</code></pre> <p>with</p> <pre><code>    &lt;arg name=\"world_name\" value=\"$(find robot_2dof_moveit_config)/worlds/warehouse_2.world\"/&gt;\n</code></pre> <p>Before the line</p> <pre><code>  &lt;!-- startup simulated world --&gt;\n</code></pre> <p>Add the following lines</p> <pre><code>  &lt;!-- warehouse simulation environment --&gt;\n  &lt;env name=\"GAZEBO_MODEL_PATH\" value=\"${GAZEBO_MODEL_PATH}:$(find robot_2dof_moveit_config)/models\"/&gt;\n  &lt;env name=\"GAZEBO_RESOURCE_PATH\" value=\"${GAZEBO_RESOURCE_PATH}:$(find robot_2dof_moveit_config)/models\"/&gt; \n</code></pre> <p>File <code>warehouse_2.world</code> contains description of the warehouse environment.</p> <p></p> <p></p>"},{"location":"simulation/#code-snapshots","title":"Code snapshots","text":""},{"location":"simulation/#snapshot-1","title":"Snapshot 1","text":""},{"location":"simulation/#file-robot2dofurdf","title":"File <code>robot2dof.urdf</code>","text":"<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"2dof_robot\"&gt;\n\n    &lt;material name=\"White\"&gt;\n        &lt;color rgba=\"1.0 1.0 1.0 1.0\"/&gt;\n    &lt;/material&gt;\n\n    &lt;material name=\"Blue\"&gt;\n        &lt;color rgba=\"0.0 0.0 1.0 1.0\"/&gt;\n    &lt;/material&gt; \n\n    &lt;material name=\"Red\"&gt;\n        &lt;color rgba=\"1 0 0 1.0\"/&gt;\n    &lt;/material&gt;\n\n    &lt;material name=\"Black\"&gt;\n        &lt;color rgba=\"0 0 0 1.0\"/&gt;\n    &lt;/material&gt;    \n\n   &lt;link name=\"world\"/&gt;\n\n   &lt;!-- BASE LINK--&gt;\n    &lt;link name=\"base_link\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.16 0.16 1.0\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"White\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;box size=\"0.16 0.16 1.0\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"25\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.5\"/&gt;\n            &lt;inertia ixx=\"8.741\" iyy=\"8.741\" izz=\"0.4367\" ixy=\"-0.1637\" ixz=\"-0.1023\"  iyz=\"-0.1023\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"fixed_base\" type=\"fixed\"&gt;\n        &lt;parent link=\"world\"/&gt;\n        &lt;child link=\"base_link\"/&gt;\n    &lt;/joint&gt;\n\n    &lt;!-- PRVI SEGMENT--&gt;\n    &lt;link name=\"prvi_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Red\"/&gt;\n            &lt;origin xyz=\"0.12 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.12 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"2.5\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.25\"/&gt;\n            &lt;inertia ixx=\"0.2091\" iyy=\"0.2091\" izz=\"0.002\" ixy=\"0.0\" ixz=\"0.0\"  iyz=\"0.0\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n\n    &lt;joint name=\"prvi_sklep\" type=\"continuous\"&gt;\n        &lt;axis xyz=\"1 0 0\"/&gt;\n        &lt;parent link=\"base_link\"/&gt;\n        &lt;child link=\"prvi_segment\"/&gt;\n        &lt;origin xyz=\"0.0 0 0.92\" rpy=\"-1.5707 0 0\"/&gt;\n    &lt;/joint&gt;\n\n     &lt;!-- DRUGI SEGMENT--&gt;\n    &lt;link name=\"drugi_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Blue\"/&gt;\n            &lt;origin xyz=\"-0.08 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"0.04\" length=\"0.5\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"-0.08 0.0 0.21\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"2.5\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.25\"/&gt;\n            &lt;inertia ixx=\"0.2091\" iyy=\"0.2091\" izz=\"0.002\" ixy=\"0.0\" ixz=\"0.0\"  iyz=\"0.0\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n\n    &lt;joint name=\"drugi_sklep\" type=\"continuous\"&gt;\n        &lt;axis xyz=\"1 0 0\"/&gt;\n        &lt;parent link=\"prvi_segment\"/&gt;\n        &lt;child link=\"drugi_segment\"/&gt;\n        &lt;origin xyz=\"0.12 0 0.42\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n\n        &lt;!-- TCP SEGMENT--&gt;\n    &lt;link name=\"TCP_segment\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"0.02\"/&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"Red\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/visual&gt;\n        &lt;collision&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"0.02\"/&gt;\n            &lt;/geometry&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n        &lt;/collision&gt;\n        &lt;inertial&gt;\n            &lt;mass value=\"0.034\"/&gt;\n            &lt;origin xyz=\"0.0 0.0 0.0\"/&gt;\n            &lt;inertia ixx=\"0.0000054\" iyy=\"0.0000054\" izz=\"0.0000054\" ixy=\"0.0\" ixz=\"0.0\"  iyz=\"0.0\"/&gt;\n        &lt;/inertial&gt;\n    &lt;/link&gt;\n\n    &lt;joint name=\"TCP_sklep\" type=\"fixed\"&gt;\n        &lt;parent link=\"drugi_segment\"/&gt;\n        &lt;child link=\"TCP_segment\"/&gt;\n        &lt;origin xyz=\"-0.08 0 0.46\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n\n    &lt;!-- PRENOSI --&gt;\n    &lt;transmission name=\"trans1\"&gt;\n        &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;\n        &lt;joint name=\"prvi_sklep\"&gt;\n            &lt;hardwareInterface&gt;hardware_interface/PositionJointInterface&lt;/hardwareInterface&gt;\n        &lt;/joint&gt;\n        &lt;actuator name=\"motor1\"&gt;\n            &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;\n        &lt;/actuator&gt;\n    &lt;/transmission&gt;\n\n    &lt;transmission name=\"trans2\"&gt;\n        &lt;type&gt;transmission_interface/SimpleTransmission&lt;/type&gt;\n        &lt;joint name=\"drugi_sklep\"&gt;\n            &lt;hardwareInterface&gt;hardware_interface/PositionJointInterface&lt;/hardwareInterface&gt;\n        &lt;/joint&gt;\n        &lt;actuator name=\"motor2\"&gt;\n            &lt;mechanicalReduction&gt;1&lt;/mechanicalReduction&gt;\n        &lt;/actuator&gt;\n    &lt;/transmission&gt;\n\n    &lt;gazebo&gt;\n        &lt;plugin name=\"control\" filename=\"libgazebo_ros_control.so\"&gt;\n            &lt;robotNamespace&gt;/MOJROBOT&lt;/robotNamespace&gt;\n        &lt;/plugin&gt;\n    &lt;/gazebo&gt; \n\n    &lt;gazebo&gt;\n        &lt;plugin name=\"joint_state_publisher\" filename=\"libgazebo_ros_joint_state_publisher.so\"&gt;\n            &lt;jointName&gt;prvi_sklep, drugi_sklep&lt;/jointName&gt;\n        &lt;/plugin&gt;\n    &lt;/gazebo&gt;      \n\n&lt;/robot&gt;\n</code></pre>"},{"location":"simulation/#file-zagon_gazebolaunch","title":"File <code>zagon_gazebo.launch</code>","text":"<pre><code>&lt;?xml version=\"1.0\"?&gt;\n\n&lt;launch&gt;\n\n    &lt;arg name=\"paused\" default=\"true\"/&gt;\n\n    &lt;param name=\"robot_description\" textfile=\"$(find robot_2dof)/urdf/robot2dof.urdf\" /&gt;\n    &lt;include file=\"$(find gazebo_ros)/launch/empty_world.launch\"&gt;\n        &lt;arg name=\"paused\" value=\"$(arg paused)\"/&gt;\n    &lt;/include&gt;    \n\n    &lt;node pkg=\"gazebo_ros\" name=\"spawn_urdf\" type=\"spawn_model\" args=\"-param robot_description -urdf -model robot2dof\" /&gt;\n\n    &lt;rosparam file=\"$(find robot_2dof)/config/controller.yaml\" command=\"load\"/&gt;\n\n    &lt;node name=\"controller_spawner\" pkg=\"controller_manager\" type=\"spawner\" respawn=\"false\" output=\"screen\" ns=\"/MOJROBOT\" \n        args=\"joint_state_controller\n        joint_controller\"/&gt; &lt;!--##NOVO--&gt;\n\n    &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" respawn=\"false\" output=\"screen\"&gt;\n        &lt;remap from=\"/joint_states\" to=\"/MOJROBOT/joint_states\" /&gt;\n    &lt;/node&gt;\n\n    &lt;!-- --&gt;\n\n&lt;/launch&gt;\n</code></pre>"},{"location":"simulation/#file-controlleryaml","title":"File <code>controller.yaml</code>","text":"<pre><code>MOJROBOT:\n  # publish all joint states:\n  joint_state_controller:\n    type: joint_state_controller/JointStateController\n    publish_rate: 10\n  joint_controller: ##NOVO\n    type: position_controllers/JointTrajectoryController ##NOVO\n    joints: ##NOVO\n    - prvi_sklep ##NOVO\n    - drugi_sklep ##NOVO\n\nMOJROBOT/gazebo_ros_control/pid_gains:\n  prvi_sklep: {p: 1000, i: 0,  d: 100}\n  drugi_sklep: {p: 1000, i: 0,  d: 100}\n</code></pre>"},{"location":"simulation/#snapshot-2","title":"Snapshot 2","text":""},{"location":"simulation/#file-ros_controllersyaml","title":"File <code>ros_controllers.yaml</code>","text":"<pre><code># Simulation settings for using moveit_sim_controllers\nmoveit_sim_hw_interface:\n  joint_model_group: arm\n  joint_model_group_pose: home\n# Settings for ros_control_boilerplate control loop\ngeneric_hw_control_loop:\n  loop_hz: 300\n  cycle_time_error_threshold: 0.01\n# Settings for ros_control hardware interface\nhardware_interface:\n  joints:\n    - prvi_sklep\n    - drugi_sklep\n  sim_control_mode: 1  # 0: position, 1: velocity\n# Publish all joint states\n# Creates the /joint_states topic necessary in ROS\nMOJROBOT:\n  joint_state_controller:\n    type: joint_state_controller/JointStateController\n    publish_rate: 50\n  arm_controller:\n    type: position_controllers/JointTrajectoryController\n    joints:\n      - prvi_sklep\n      - drugi_sklep\n    gains:\n      prvi_sklep:\n        p: 100\n        d: 1\n        i: 1\n        i_clamp: 1\n      drugi_sklep:\n        p: 100\n        d: 1\n        i: 1\n        i_clamp: 1\n\ncontroller_list:\n  - name: MOJROBOT/arm_controller\n    action_ns: follow_joint_trajectory\n    type: FollowJointTrajectory\n    default: true\n    joints:\n      - prvi_sklep\n      - drugi_sklep    \n</code></pre>"},{"location":"simulation/#file-ros_controllerslaunch","title":"File <code>ros_controllers.launch</code>","text":"<pre><code>&lt;?xml version=\"1.0\"?&gt;\n&lt;launch&gt;\n\n  &lt;!-- Load joint controller configurations from YAML file to parameter server --&gt;\n  &lt;rosparam file=\"$(find robot_2dof_moveit_config)/config/ros_controllers.yaml\" command=\"load\"/&gt;\n\n  &lt;!-- Load the controllers --&gt;\n  &lt;node name=\"controller_spawner\" pkg=\"controller_manager\" type=\"spawner\" respawn=\"false\"\n    output=\"screen\" args=\"--namespace=/MOJROBOT\n    joint_state_controller\n    arm_controller\n    --timeout 20\"/&gt;\n\n&lt;/launch&gt;\n</code></pre>"},{"location":"simulation/#file-demo_gazebolaunch","title":"File <code>demo_gazebo.launch</code>","text":"<pre><code>&lt;launch&gt;\n\n  &lt;!-- By default, we do not start a database (it can be large) --&gt;\n  &lt;arg name=\"db\" default=\"false\" /&gt;\n  &lt;!-- Allow user to specify database location --&gt;\n  &lt;arg name=\"db_path\" default=\"$(find robot_2dof_moveit_config)/default_warehouse_mongo_db\" /&gt;\n\n  &lt;!-- By default, we are not in debug mode --&gt;\n  &lt;arg name=\"debug\" default=\"false\" /&gt;\n\n  &lt;!-- By default, we won't load or override the robot_description --&gt;\n  &lt;arg name=\"load_robot_description\" default=\"false\"/&gt;\n\n  &lt;!--\n  By default, hide joint_state_publisher's GUI\n\n  MoveIt!'s \"demo\" mode replaces the real robot driver with the joint_state_publisher.\n  The latter one maintains and publishes the current joint configuration of the simulated robot.\n  It also provides a GUI to move the simulated robot around \"manually\".\n  This corresponds to moving around the real robot without the use of MoveIt.\n  --&gt;\n  &lt;arg name=\"use_gui\" default=\"false\" /&gt;\n\n  &lt;!-- Gazebo specific options --&gt;\n  &lt;arg name=\"gazebo_gui\" default=\"true\"/&gt;\n  &lt;arg name=\"paused\" default=\"false\"/&gt;\n  &lt;!-- By default, use the urdf location provided from the package --&gt;\n  &lt;arg name=\"urdf_path\" default=\"$(find robot_2dof)/urdf/robot2dof.urdf\"/&gt;\n\n  &lt;!-- launch the gazebo simulator and spawn the robot --&gt;\n  &lt;include file=\"$(find robot_2dof_moveit_config)/launch/gazebo.launch\" &gt;\n    &lt;arg name=\"paused\" value=\"$(arg paused)\"/&gt;\n    &lt;arg name=\"gazebo_gui\" value=\"$(arg gazebo_gui)\"/&gt;\n    &lt;arg name=\"urdf_path\" value=\"$(arg urdf_path)\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- If needed, broadcast static tf for robot root --&gt;\n\n\n  &lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\"&gt;\n    &lt;param name=\"use_gui\" value=\"$(arg use_gui)\"/&gt;\n    &lt;rosparam param=\"source_list\"&gt;[MOJROBOT/joint_states]&lt;/rosparam&gt;\n  &lt;/node&gt;\n\n  &lt;!-- We do not have a robot connected, so publish fake joint states \n  &lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher\" type=\"joint_state_publisher\" unless=\"$(arg use_gui)\"&gt;\n    &lt;rosparam param=\"source_list\"&gt;[move_group/fake_controller_joint_states]&lt;/rosparam&gt;\n    &lt;rosparam param=\"source_list\"&gt;[MOJROBOT/joint_states]&lt;/rosparam&gt;\n  &lt;/node&gt;\n  &lt;node name=\"joint_state_publisher\" pkg=\"joint_state_publisher_gui\" type=\"joint_state_publisher_gui\" if=\"$(arg use_gui)\"&gt;\n    &lt;rosparam param=\"source_list\"&gt;[move_group/fake_controller_joint_states]&lt;/rosparam&gt;\n    &lt;rosparam param=\"source_list\"&gt;[MOJROBOT/joint_states]&lt;/rosparam&gt;\n  &lt;/node&gt;--&gt;\n\n  &lt;!-- Given the published joint states, publish tf for the robot links --&gt;\n  &lt;node name=\"robot_state_publisher\" pkg=\"robot_state_publisher\" type=\"robot_state_publisher\" respawn=\"true\" output=\"screen\" /&gt;\n\n  &lt;!-- Run the main MoveIt! executable without trajectory execution (we do not have controllers configured by default) --&gt;\n  &lt;include file=\"$(find robot_2dof_moveit_config)/launch/move_group.launch\"&gt;\n    &lt;arg name=\"allow_trajectory_execution\" value=\"true\"/&gt;\n    &lt;arg name=\"fake_execution\" value=\"false\"/&gt;\n    &lt;arg name=\"info\" value=\"true\"/&gt;\n    &lt;arg name=\"debug\" value=\"$(arg debug)\"/&gt;\n    &lt;arg name=\"load_robot_description\" value=\"$(arg load_robot_description)\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- Run Rviz and load the default config to see the state of the move_group node --&gt;\n  &lt;include file=\"$(find robot_2dof_moveit_config)/launch/moveit_rviz.launch\"&gt;\n    &lt;arg name=\"rviz_config\" value=\"$(find robot_2dof_moveit_config)/launch/moveit.rviz\"/&gt;\n    &lt;arg name=\"debug\" value=\"$(arg debug)\"/&gt;\n  &lt;/include&gt;\n\n  &lt;!-- If database loading was enabled, start mongodb as well --&gt;\n  &lt;include file=\"$(find robot_2dof_moveit_config)/launch/default_warehouse_db.launch\" if=\"$(arg db)\"&gt;\n    &lt;arg name=\"moveit_warehouse_database_path\" value=\"$(arg db_path)\"/&gt;\n  &lt;/include&gt;\n\n&lt;/launch&gt;\n</code></pre> <p>https://github.com/wh200720041/warehouse_simulation_toolkit</p> <p>robot_2dof_moveit_config.zip</p>"},{"location":"simulation/#common-pitfalls-and-tips-for-creating-urdf-files","title":"Common Pitfalls and Tips for Creating URDF Files","text":"<p>Creating URDF (Unified Robot Description Format) files can be challenging, especially for beginners. Small errors in URDF files can lead to significant issues in robot simulation, control, and motion planning. In this section, we will discuss some common pitfalls encountered while creating URDF files and provide tips to avoid these errors. Understanding these pitfalls and best practices will help ensure your robot models are accurate, functional, and easy to debug.</p>"},{"location":"simulation/#incorrect-syntax-and-formatting-errors","title":"Incorrect Syntax and Formatting Errors","text":"<p>Pitfall: One of the most common issues with URDF files is incorrect syntax or formatting, such as missing tags, incorrect nesting of elements, or improperly closed tags. URDF is based on XML, which is strict about structure and format. Any deviation from the proper syntax will cause the parser to fail, resulting in errors when loading the robot model.</p> <p>Tips:</p> <ul> <li>Use a Code Editor with XML Syntax Highlighting: An editor that highlights XML syntax can help spot missing or mismatched tags. Some editors also offer real-time validation and suggest corrections.</li> <li>Validate URDF Files: Use ROS tools like check_urdf to validate the syntax of your URDF file. This tool checks for XML errors and validates that all required tags are present.</li> <li>Keep XML Clean and Readable: Properly indent your URDF file to make it more readable and easier to spot syntax errors. This will also help in understanding the hierarchy of elements, such as links and joints.</li> </ul> <p>Example Command for Validation:</p> <pre><code>rosrun urdf_parser_py check_urdf my_robot.urdf\n</code></pre>"},{"location":"simulation/#incorrect-inertia-and-mass-properties","title":"Incorrect Inertia and Mass Properties","text":"<p>Pitfall: Incorrectly defining inertia and mass properties can cause unrealistic physical behaviors in the simulation. For example, setting the mass too high or too low can lead to unstable simulations, and incorrect inertia values can cause unexpected rotations or movements.</p> <p>Tips: - Calculate Accurate Inertia Values: Use tools or scripts to calculate accurate inertia tensors for different shapes. For simple geometries like boxes, cylinders, and spheres, the inertia can be calculated using standard formulas. For complex shapes, consider using CAD software or specialized tools to compute the inertia tensor. - Set Realistic Mass Values: Ensure that the mass values for each link are realistic relative to the robot\u2019s size and material. Unrealistic mass values can make the simulation behave incorrectly, such as making a robot too heavy to move or too light to stand still. - Test Physical Properties Incrementally: Start with simple simulations to test physical properties. Gradually add complexity and adjust mass and inertia values to observe how they affect the simulation.</p>"},{"location":"simulation/#incorrect-joint-definitions-and-limits","title":"Incorrect Joint Definitions and Limits","text":"<p>Pitfall: Defining joints incorrectly, such as misconfiguring their type, axis of rotation, or limits, can lead to unexpected robot behavior. This could cause joints to move in unintended ways, become locked, or result in instability during simulation.</p> <p>Tips:</p> <ul> <li>Correctly Define Joint Types: Ensure the joint type (e.g., revolute, prismatic, fixed) matches the intended movement for each connection between links. A common mistake is to set a joint type incorrectly, causing the robot to behave in an unintended manner.</li> <li>Set Appropriate Joint Limits: Define realistic lower and upper limits for each joint to avoid unnatural movements. For example, a human-like arm joint should have a limited range to reflect real-world constraints.</li> <li>Align Joint Axis Properly: Ensure the joint\u2019s axis of rotation or translation is correctly aligned. Misaligned axes can cause the robot parts to move in unexpected directions.</li> </ul> <p>Example URDF Snippet for a Correct Joint Definition:</p> <pre><code>&lt;joint name=\"elbow_joint\" type=\"revolute\"&gt;\n  &lt;parent link=\"upper_arm\" /&gt;\n  &lt;child link=\"lower_arm\" /&gt;\n  &lt;origin xyz=\"0 0 1\" rpy=\"0 0 0\" /&gt;\n  &lt;axis xyz=\"0 0 1\" /&gt;\n  &lt;limit lower=\"-1.57\" upper=\"1.57\" effort=\"50\" velocity=\"1.0\" /&gt;\n&lt;/joint&gt;\n</code></pre>"},{"location":"simulation/#misaligned-visual-and-collision-elements","title":"Misaligned Visual and Collision Elements","text":"<p>Pitfall: Misalignment between visual and collision elements can cause issues where the robot appears correctly but does not interact with the environment as expected. For example, the robot might visually clear an obstacle, but its collision model might still make contact, causing unexpected behavior.</p> <p>Tips:</p> <ul> <li>Ensure Alignment of Visual and Collision Geometries: When defining the visual and collision elements, make sure they are aligned and positioned correctly relative to each other. Use the same origin and orientation where possible to avoid discrepancies.</li> <li>Simplify Collision Models: Use simpler geometries for collision models to reduce computational load and improve simulation performance. It is common practice to use basic shapes (boxes, cylinders, spheres) for collision while keeping complex shapes for visual representation.</li> <li>Visualize Collision Models in Simulation: Enable collision model visualization in Gazebo to verify that they match the visual models and are positioned correctly. This can help identify and correct misalignments.</li> </ul> <p>Example URDF Snippet for Aligned Visual and Collision Elements:</p> <pre><code>&lt;visual&gt;\n  &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;\n  &lt;geometry&gt;\n    &lt;mesh filename=\"package://my_robot/meshes/visual/arm.stl\" scale=\"1 1 1\" /&gt;\n  &lt;/geometry&gt;\n&lt;/visual&gt;\n&lt;collision&gt;\n  &lt;origin xyz=\"0 0 0\" rpy=\"0 0 0\" /&gt;\n  &lt;geometry&gt;\n    &lt;box size=\"0.1 0.1 1.0\" /&gt;\n  &lt;/geometry&gt;\n&lt;/collision&gt;\n</code></pre>"},{"location":"simulation/#overly-complex-urdf-files","title":"Overly Complex URDF Files","text":"<p>Pitfall: Creating an overly complex URDF file with too many details, high-resolution meshes, or unnecessary elements can make the robot model difficult to manage, slow to load, and hard to debug.</p> <p>Tips:</p> <ul> <li>Use Simplified Models for Prototyping: Start with simplified robot models to test the basic functionality before adding complexity. This makes debugging easier and speeds up the simulation.</li> <li>Optimize Meshes for Performance: When using mesh files, ensure they are optimized for performance. High-resolution meshes can drastically slow down the simulation. Use lower-resolution meshes for collision elements and consider using simpler geometries where possible.</li> <li>Modularize URDF Files: Break down the URDF into smaller, manageable files using the  format, which allows for parameterization and reuse of components. This approach makes the URDF easier to read, edit, and maintain."},{"location":"simulation/#not-accounting-for-ros-and-gazebo-integration-differences","title":"Not Accounting for ROS and Gazebo Integration Differences","text":"<p>Pitfall: Failing to account for differences between how ROS and Gazebo interpret URDF files can lead to discrepancies between simulation and real-world behavior. For example, certain tags like  are not used by Gazebo directly but are essential for ROS Control. <p>Tips:</p> <ul> <li>Separate Simulation-Specific Tags: Use Gazebo-specific tags within  elements to define properties like friction, damping, or custom sensors that are only relevant to the simulation. <li>Ensure Consistency Between Simulation and Real-World Models: When defining transmissions and controllers, ensure that the URDF\u2019s hardware interface definitions align with both Gazebo and ROS Control requirements.</li> <li>Test in Both Environments: Regularly test the URDF in both Gazebo and ROS environments to ensure consistent behavior and to identify any discrepancies early on.</li> <p>Example URDF Snippet for Gazebo-Specific Tags:</p> <pre><code>&lt;gazebo&gt;\n  &lt;sensor type=\"camera\" name=\"camera\"&gt;\n    &lt;update_rate&gt;30&lt;/update_rate&gt;\n    &lt;camera&gt;\n      &lt;horizontal_fov&gt;1.047&lt;/horizontal_fov&gt;\n      &lt;image&gt;\n        &lt;width&gt;640&lt;/width&gt;\n        &lt;height&gt;480&lt;/height&gt;\n        &lt;format&gt;R8G8B8&lt;/format&gt;\n      &lt;/image&gt;\n      &lt;clip&gt;\n        &lt;near&gt;0.1&lt;/near&gt;\n        &lt;far&gt;100&lt;/far&gt;\n      &lt;/clip&gt;\n    &lt;/camera&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;\n</code></pre>"},{"location":"sponsors/","title":"FE ROS Sponsors","text":"<p>The FE ROS organizers would like to thank the sponsors for the various resources that helped us carry out the workshop.</p>"},{"location":"tf_moveit/","title":"Introduction","text":"<p>Welcome to the part of the workshop where you will learn how to work with frame transformations and trajectory planning.</p> <p></p> <p>At the end of this day you will be able to do the following:</p> <ul> <li>Write the relations between coordinate frames in a URDF file</li> <li>Publish custom transformation either from a Python script or command line</li> <li>Get the transformation between two arbitrary transforms</li> <li>Understand the relation between joint state publisher and robot state publisher</li> <li>Use Rviz to visualize the robot and the coordinate frames</li> <li>Use Rviz to plan a trajectory that brings the robot from one configuration to another whilst avoiding collisions</li> <li>Use the MoveIt API to plan and execute robot trajectories</li> <li>Write a tool to save the current robot state - used for programming robot motions</li> </ul>"},{"location":"tf_moveit/assignment/","title":"Assignment","text":""},{"location":"tf_moveit/assignment/#assignment","title":"Assignment","text":"<p>At the end of this assignment you will have a set of tools that you can use during the practical part of the workshop. So do your best to make it as useful and easy-to-use as possible.</p>"},{"location":"tf_moveit/assignment/#first-part-of-the-assignment","title":"First part of the assignment","text":"<p>Using the joint state publisher and a simulated robot save various joint and Cartesian space configurations into a Pickle file. Use the scripts that you wrote in the previous assignment.</p> <p>Make sure to store at least 4 configurations and make them \"more or less\" meaningful. For instance, a \"home\" position, an \"approach\" position, an \"away from everythin\" position, etc.</p> <p>Here are a couple of hints that will make your life easier on the long-term (but you will hate on the short-term):</p> <ul> <li>Always save both joints and Cartesian space data: <code>data['frame1'] = [joints, transform]</code></li> <li>Use <code>raw_input</code> to define the name under which you want to store data:</li> </ul> <pre><code>...\nnew_name = raw_input(\"Please provide the name for the new item\")\n...\ntransform.child_frame_id = new_name\ndata[new_name] = transform\n...\n</code></pre> <ul> <li>Visualize the frames in Rviz</li> <li>Try to define the full path of the location of the file</li> <li>The names should following the \"snake case\" style: <code>this_is_a_name</code></li> </ul>"},{"location":"tf_moveit/assignment/#second-part-of-the-assignment","title":"Second part of the assignment","text":"<p>Using the Pickle file that you created in the first part of the assignment, you will publish the messages that were stored as <code>TransformStamped</code> onto TF. You will do so using the script that you write in the previous assignments.</p> <p>Next, you will move the simulated robot into these configurations. Help yourselves with the convenient methods: <code>transformstamped_to_pose</code> and <code>get_pose_from_tf</code>. You will find the code snippets below.</p>"},{"location":"tf_moveit/assignment/#transformstamped_to_pose","title":"<code>transformstamped_to_pose</code>","text":"<pre><code>def transformstamped_to_pose(transform_stamped):\n    \"\"\"Convert from geometry_msgs/TransformStamped to geometry_msgs/Pose\n\n    Args:\n        transform_stamped (geometry_msgs/TransformStamped): The geometry_msgs/TransformStamped message to convert\n\n    Returns:\n        Pose: The geometry_msgs/Pose message\n    \"\"\"\n    return Pose(position=transform_stamped.transform.translation, orientation=transform_stamped.transform.rotation)\n</code></pre>"},{"location":"tf_moveit/assignment/#get_pose_from_tf","title":"<code>get_pose_from_tf</code>","text":"<pre><code>def get_pose_from_tf(target, tf_buffer, relative_to='base_link'):\n    \"\"\"Return a Pose object to the desired TF frame\n\n    Args:\n        target (str): TF frame that we are interested in\n        tf_buffer (tf2_ros.Buffer): A TF buffer. Don't forget to initialize it with the listener!!!\n        relative_to (str, optional): Relative to ...\n\n    Return:\n        Pose: The TF frame expressed as geometry_msgs/Pose\n    \"\"\"\n\n    rospy.sleep(0.1)\n    target_transform = tf_buffer.lookup_transform(relative_to, target, rospy.Time(0))\n    return transformstamped_to_pose(target_transform)\n</code></pre> <p>The assignment is completed once you show that your robot moved in at least 4 configurations, both in joint and Cartesian space.</p> <p>Good luck.</p>"},{"location":"tf_moveit/moveit/","title":"Planning trajectories with MoveIt","text":""},{"location":"tf_moveit/moveit/#moveit","title":"MoveIt","text":"<p>In this section we will learn how to plan and execute robot trajectories using MoveIt.</p>"},{"location":"tf_moveit/moveit/#what-is-moveit","title":"What is MoveIt?","text":"<p>From their Github repository:</p> <p>Easy-to-use open source robotics manipulation platform for developing commercial applications, prototyping designs, and benchmarking algorithms.</p> <p>The best way to show why MoveIt is cool and how you can use it is by providing a demo. We've prepared a simple launch file that starts Rviz (you will learn about this later) with the MoveIt plug in. You will first need to download and install the <code>fe_urko</code> package available on Github: https://github.com/ROS-FE/fe_urko. After installing it and sourcing the workspace, you can run the following launchfile: <pre><code>$ roslaunch fe_urko urko_moveit_demo.launch\n</code></pre></p> <p>Note: Do not forget to install the dependencies!</p>"},{"location":"tf_moveit/moveit/#understanding-the-moveit-architecture","title":"Understanding the MoveIt architecture","text":"<p>Note: The images displayed in this section were taken from the documentation available at https://moveit.ros.org/documentation/concepts/</p> <p></p>"},{"location":"tf_moveit/moveit/#the-move-group","title":"The Move Group","text":"<p>This is the node that is the central program that combines all the available environment data and user requests in order to provide a trajectory that leads the robot from one configuration to the next by using the available motion planners.</p>"},{"location":"tf_moveit/moveit/#robot-description","title":"Robot description","text":"<p>The robot you saw in the demo before was defined in a URDF file (with a combination of XACRO). This defines the model of the robot, the parts that we don't expect to change beyond the normal motions of its actuators.</p>"},{"location":"tf_moveit/moveit/#semantic-description","title":"Semantic description","text":"<p>The URDF file might describe a system with hundreds of frames. The so called semantic description (a <code>.srdf</code> file) tells the Move Group which are the frames that constitute our robot. Moreover, it tells what object pairs (i.e. frames with some shape attached to them) are to be ignored when checking collisions.</p>"},{"location":"tf_moveit/moveit/#the-environment","title":"The environment","text":"<p>MoveIt is aware of the robot's environment while planning trajectories. This environment can be divided in two groups: the URDF (i.e. robot description, what we know) and the planning scene (what we detect).</p> <p>The instructor shows how to add a cube into the planning scene through the user interface</p>"},{"location":"tf_moveit/moveit/#moveit-python-api","title":"MoveIt Python API","text":"<p>Playing with a graphical interface to see how a robot can move in an environment is fun but not too useful for solving practical programs. We are robot programmers, which means we want to write robot programs. This is precisely the aim of this section - explore the Python API and how it can be used to program robot motions.</p> <p>Let's start with the following code snippet: <pre><code>#!/usr/bin/env python2\n\nimport rospy\nfrom sensor_msgs.msg import JointState\n\nJOINT_NAMES = [\n    'shoulder_pan_joint',\n    'shoulder_lift_joint',\n    'elbow_joint',\n    'wrist_1_joint',\n    'wrist_2_joint',\n    'wrist_3_joint'\n]\n\nHOME_JOINTS = [0.0, -1.57, -1.57, 0, 0.0, 0.0]\n\nif __name__ == '__main__':\n    rospy.init_node('moveit_programmer')\n\n    joint_pub = rospy.Publisher('/move_group/fake_controller_joint_states', JointState, queue_size=10)\n    rospy.sleep(0.1)\n\n    init_joints = JointState()\n    init_joints.header.stamp = rospy.Time.now()\n    init_joints.name = JOINT_NAMES\n    init_joints.position = HOME_JOINTS\n    joint_pub.publish(init_joints)\n    #########################\n    ##### STUDENT WRITES ####\n    #########################\n\n\n    #########################\n</code></pre></p> <p>This code snippet publishes the initial joint configuration on the <code>/move_group/fake_controller_joint_states</code> topic and then quits. The <code>joint_state_publisher</code> node reads the values published on this topic and copies them. Which means, that whenever we start this node, our simulated robot will be in some sort of initial position.</p> <p>Paste this code snippet in a file called <code>moveit_programmer.py</code> and make it executable (<code>chmod +x ...</code>). We are now going to write the code in the marked section of the code.</p>"},{"location":"tf_moveit/moveit/#simple-motion-to-target-joint-positions","title":"Simple motion to target joint positions","text":"<p>To start using MoveIt in our Python code, we must first import it: <code>import moveit_commander</code>. Next, we need to create an instance of the <code>MoveGroupCommander</code>: <pre><code>...\n    moveit_interface = moveit_commander.MoveGroupCommander('manipulator')\n...\n</code></pre></p> <p>We can now use the full range of the MoveIt's Python API. Let's try something simple: get the current values of the robot's joints: <pre><code>...\n    joint_goal = moveit_interface.get_current_joint_values()\n    print(joint_goal)\n...\n</code></pre></p> <p>The <code>get_current_joint_values</code> method returns the current joint values (duh) as a Python list. If you have added these three lines into the <code>moveit_programmer.py</code> script and executed it, you should see the following print to the standard output: <pre><code>$ rosrun  fe_tf moveit_programming.py\n[ INFO] [1663002388.870181400]: Loading robot model 'ur10e_robot'...\n[ INFO] [1663002390.056249500]: Ready to take commands for planning group manipulator.\n[0.0, -1.5707963267949996, -1.5701680082642822, 0.0, 0.0, 0.0]\n</code></pre></p> <p>Let's modify the 2nd element in this list by changing its sign and instruct MoveIt to move the robot there: <pre><code>    joint_goal[2] = - HOME_JOINTS[2]\n    moveit_interface.go(joint_goal, wait=True)\n</code></pre> If all goes well, you should see the virtual robot move. Yay!</p>"},{"location":"tf_moveit/moveit/#first-assignment","title":"First assignment","text":"<p>Write a program in Python that will guide the robot from the previously defined home position (i.e. <code>[0.0, -pi/2, -pi/2, 0.0, 0.0, 0.0]</code>) to two different joint space configurations, one after another, using MoveIt Python API.</p> <p>After this is working, try modifying the speed of the motion with the <code>set_max_velocity_scaling_factor()</code> method. The method takes a value between 0 and 1 (0% and 100%). Similarly, you can play around with <code>set_max_acceleration_scaling_factor()</code> to modify the maximum allowed accelerations.</p>"},{"location":"tf_moveit/moveit/#cartesian-space-motions","title":"Cartesian space motions","text":"<p>Now you are an expert in moving the robot in joint space, let's also make you an expert in moving the robot to Cartesian space. This is extremely useful as sometimes a target is defined relative to the robot base and we don't know the final joint configuration of the target. Luckily, MoveIt has an inverse kinematics solver integrated so we don't need to program one. Moreover, we can use the <code>go()</code> method with a <code>Pose</code> object!</p> <p>Add the following imports to your script:</p> <pre><code>import tf2_ros\nfrom geometry_msgs.msg import Pose\n</code></pre> <p>Next, we will get the Cartesian space coordinates of the robot's end-effector. We will then increase the value of the <code>z</code> coordinate by 10 cm and send this as a target to MoveIt. We will be using the <code>tf</code> library that we mastered in the previous chapter. Pay attention to the snippet below - before we feed the target to MoveIt, we convert it from <code>TransformStamped</code> into <code>Pose</code>.</p> <pre><code># Move in Cartesian space\ntf_buffer = tf2_ros.Buffer()\ntf_listener = tf2_ros.TransformListener(tf_buffer)\n\nrospy.sleep(0.5)\n\ncurrent_transform = tf_buffer.lookup_transform(\n    'base_link',\n    'tool0',\n    rospy.Time(0)\n)\n\nprint(current_transform.transform)\nraw_input(\"Press Enter\")\npose_goal = Pose(\n    position=current_transform.transform.translation, orientation=current_transform.transform.rotation)\npose_goal.position.z += 0.1\nmoveit_interface.go(pose_goal, wait=True)\n</code></pre> <p>Depending on the solution of the inverse kinematic solver, you've probably witnessed either a rather elegant motion or something that made you wonder if the robot is going into the right direction. Rest assured, it is.</p> <p>Let's try the same approach but this time we get the transform of a frame the we published on the with the <code>static static_transform_publisher</code>. Open a separate terminal and type the following:</p> <pre><code>$ rosrun tf2_ros static_transform_publisher 0.7 0 0.5 0 0 0 1 base_link target_1\n</code></pre> <p>We modify the Python code into the following (or add it): <pre><code>target_transform = tf_buffer.lookup_transform(\n    'base_link',\n    'target_1',\n    rospy.Time(0)\n)\n\nprint(target_transform.transform)\npose_goal = Pose(\n    position=target_transform.transform.translation, orientation=target_transform.transform.rotation)\nmoveit_interface.go(pose_goal, wait=True)\n</code></pre></p>"},{"location":"tf_moveit/moveit/#relative-motions","title":"Relative motions","text":"<p>If our target frames are nicely aligned to the base frame of the robot (like in the case of <code>target_1</code>) it is pretty simple to estimate the approach positions. We add a little bit of an offset to the <code>Z</code> axis and we see that the robot will approach from above. However, what if this is not the case. For instance, the target is tilted by *a few* degrees (something random, like 42). Then it would be practical to make the approach relative to the target's frame.</p> <p>To achieve this, we can use <code>tf</code> again. This time, we can publish an additional frame to the target frame, and make this our new target. Confusing? Sure, that's why programmers express themselves with code :)</p> <pre><code># Create a static transform broadcaster object\ntf_broadcaster = tf2_ros.StaticTransformBroadcaster()\n\n# Use the previously acquired target and add a bit of an offset on the z axis\ntarget_transform.transform.translation.z += 0.1\ntarget_transform.child_frame_id = 'target_offset'\n\n# Publish the frame and give the broadcaster some time\ntf_broadcaster.sendTransform(target_transform)\nrospy.sleep(0.5)\n\n# Now lookup the transform from the robot's base to the target offset\noffset_transform = tf_buffer.lookup_transform(\n    'base_link',\n    'target_offset',\n    rospy.Time(0)\n)\n\n# Convert it to pose and send it to the robot\npose_goal = Pose(\n    position=offset_transform.transform.translation, orientation=offset_transform.transform.rotation)\nmoveit_interface.go(pose_goal, wait=True)\n</code></pre> <p>The MoveIt Python API also provides a method to plan a motion relative to the end-effector's relative coordinate system. This method is called <code>shift_pose_target</code> and if we look at the source code the definition and docstring look like this: <pre><code>...\ndef shift_pose_target(self, axis, value, end_effector_link=\"\"):\n    \"\"\" Get the current pose of the end effector, add value to the corresponding axis (0..5: X, Y, Z, R, P, Y) and set the new pose as the pose target \"\"\"\n...\n</code></pre></p> <p>As you can see, it can create a motion target along one of the 6 axis of the end effector. Let's try to move the end effector by 10 cm along the <code>X</code> axis: <pre><code># Add an offset to the tool\nmoveit_interface.shift_pose_target(1, 0.1)\nmoveit_interface.execute(moveit_interface.plan(), wait=True)\n</code></pre></p> <p>Note: If using Python3, the correct syntax is: <code>moveit_interface.execute(moveit_interface.plan()[1], wait=True)</code></p> <p>You will notice, that now we don't use the <code>go()</code> method anymore but <code>plan()</code> and <code>execute()</code> in succession. This is also a very valid use of MoveIt as it allows us to evaluate the plans. However, this is not the topic of today's workshop.</p>"},{"location":"tf_moveit/moveit/#intermediate-assignment","title":"Intermediate assignment","text":"<p>Using all of the above techniques, simulate a pick and place motion, starting from the previously defined home joints (i.e. <code>[0.0, -pi/2, -pi/2, 0.0, 0.0, 0.0]</code>). The robot will first approach a target called <code>object</code> 15 cm above. Then it will move to the target. When at the target, it will make a slight motion downwards and push into the target for 0.5 cm. Finally, it will lift up about 20 cm above the target and return to the home joints.</p>"},{"location":"tf_moveit/tf/","title":"Transformations","text":""},{"location":"tf_moveit/tf/#transformations","title":"Transformations","text":"<p>In the first part of this day's workshop, we will learn how can we publish, read and visualize transformations.</p>"},{"location":"tf_moveit/tf/#what-is-tf","title":"What is TF?","text":"<p>From TF's wiki page:</p> <p>tf is a package that lets the user keep track of multiple coordinate frames over time.</p> <p>In this part of the workshop, you will learn how we can use TF in practice and what needs to be taken care of.</p>"},{"location":"tf_moveit/tf/#wheres-the-information","title":"Where's the information","text":"<p>The transformation data between the various frames is available across two different topics: <code>/tf_static</code> and <code>/tf</code>.</p> <p>As the name suggests, the <code>/tf_static</code> topic holds the transformation data between frames that are, well, static! Whereas <code>/tf</code> holds the transformation data between frames which relations change. Let's learn how the two of them differ from one another in practice!</p>"},{"location":"tf_moveit/tf/#tf-static-publisher","title":"TF static publisher","text":"<p>The static publisher is very useful to publish spatial transformation data that we don't expect to change. In robotics that might be the relation between the robot's base and a fixed point in it's proximity. For example, the transformation between the robot's base and the origin of the table that the robot is mounted on.</p>"},{"location":"tf_moveit/tf/#command-line-demonstration","title":"Command line demonstration","text":"<p>Open three terminals. In the first terminal, run the following command: <pre><code>$ rosrun tf2_ros static_transform_publisher 0 0 1 0 0 0 world frame_1\n</code></pre></p> <p>In the second terminal, run the following command: <pre><code>$ rosrun tf2_ros static_transform_publisher 0 0 2 0 0 0 frame_1 frame_2\n</code></pre></p> <p>Leave these two terminals open and switch to the third.</p> <p>Let's inspect the content of the <code>/tf_static</code> topic: <pre><code>$ rostopic echo /tf_static\n</code></pre> What do you see? How many messages did you receive? Are they periodic?</p> <p>Ok, now let's retrieve the transformation between <code>world</code> and <code>frame_2</code>. What do you expect to be the result? <pre><code>$ rosrun tf tf_echo world frame_2\n</code></pre></p> <p>Note: The <code>tf_echo</code> tool is very useful to evaluate the transformation between two frames on TF.</p>"},{"location":"tf_moveit/tf/#python-demonstration","title":"Python demonstration","text":"<p>Before we proceed we will kill the programs (both <code>static_transform_publisher</code>s and <code>tf_echo</code>) that we started before.</p> <p>Let's get our hands dirty with Python right away. Take the following code snipped and create a script called <code>simple_static_broadcaster.py</code>:</p> <pre><code>#! /usr/bin/env python\n\nimport rospy\nimport tf2_ros\nfrom geometry_msgs.msg import TransformStamped\n\nif __name__ == '__main__':\n\n    rospy.init_node('tf_static_broadcaster')\n\n    tf_broad = tf2_ros.StaticTransformBroadcaster()\n\n    frame_1 = TransformStamped()\n    frame_1.child_frame_id = 'frame_1'\n    frame_1.header.frame_id = 'world'\n\n    frame_1.transform.rotation.w = 1.0\n\n    frame_1.transform.translation.z = 1.0\n    frame_1.transform.translation.y = 0.0\n    frame_1.transform.translation.x = 0.0\n\n    rospy.loginfo(\"Publishing transform from {0} to {1}\".format(frame_1.header.frame_id, frame_1.child_frame_id))\n    tf_broad.sendTransform([frame_1])\n\n    rospy.spin()\n</code></pre> <p>Run the script. Explore the <code>/tf_static</code> topic again. What do we see?</p> <p>Note: Do not forget to make it executable with <code>chmod +x simple_static_broadcaster.py</code>.</p>"},{"location":"tf_moveit/tf/#intermediate-assignment","title":"Intermediate assignment","text":"<p>Write a Python script (name it <code>multiple_frames_static.py</code>) that publishes three frames: <code>world</code>, <code>frame_1</code> and <code>frame_2</code>. The relations between them should be as follows:</p> <ul> <li><code>frame_1</code> is offset by 1m along the <code>Z</code> axis from <code>world</code></li> <li><code>frame_2</code> is offset by 1m along the <code>X</code> axis from <code>frame_1</code></li> </ul> <p>Check with <code>tf_echo</code> the relation between <code>world</code> and <code>frame_2</code>. You should see the following output in the command line: <pre><code>At time 0.000\n- Translation: [1.000, 0.000, 1.000]\n- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]\n            in RPY (radian) [0.000, -0.000, 0.000]\n            in RPY (degree) [0.000, -0.000, 0.000]\n</code></pre></p>"},{"location":"tf_moveit/tf/#tf-publisher","title":"TF publisher","text":"<p>When we want to publish transformation that we know change often, we rather use the \"normal\" TF publisher. That is, not static.</p> <p>This type of publisher does not have a command line interface. That's why we will dig into a Python example right away.</p>"},{"location":"tf_moveit/tf/#python-demonstration_1","title":"Python demonstration","text":"<p>To start with, let's create a copy of the <code>simple_static_broadcaster.py</code> script and call it <code>simple_tf_broadcaster.py</code>. Change the file so that instead of <code>StaticTransformBroadcaster()</code> we use <code>TransformBroadcaster()</code>.</p> <p>After you modified the file run the script. Observe the contents of <code>/tf_static</code> and <code>/tf</code> topic. Seeing any messages?</p> <p>The reason why you don't see any messages is because <code>TransformBroadcaster()</code> publishes to <code>/tf</code>, which is not a latched topic. Your script published exactly one message to <code>/tf</code> and then got stuck in the <code>rospy.spin()</code>. To confirm that, subscribe to the <code>/tf</code> topic again and start the script, you will see just one message.</p> <p>Note: You might need to add <code>rospy.sleep(0.1)</code> just before sending the transform. Sometimes, the <code>TransformBroadcaster()</code> needs some time to set everything up.</p> <p>Let's now write a script, that publishes the frame with a constant frequency: <pre><code>#! /usr/bin/env python\n\nimport rospy\nimport tf2_ros\nfrom geometry_msgs.msg import TransformStamped\n\nif __name__ == '__main__':\n\n    rospy.init_node('tf_broadcaster')\n\n    tf_broad = tf2_ros.TransformBroadcaster()\n\n    frame_1 = TransformStamped()\n    frame_1.child_frame_id = 'frame_1'\n    frame_1.header.frame_id = 'world'\n\n    frame_1.transform.rotation.w = 1.0\n\n    frame_1.transform.translation.z = 1.0\n    frame_1.transform.translation.y = 0.0\n    frame_1.transform.translation.x = 0.0\n\n    while not rospy.is_shutdown():\n        tf_broad.sendTransform([frame_1])\n        rospy.sleep(0.01)\n</code></pre></p> <p>As you see, we no longer require the <code>rospy.spin()</code>. That is because we use a <code>while</code> loop that does not exit unless we interrupt the execution of the Python script.</p> <p>Let's inspect the TF topics. As you expect, the <code>/tf_static</code> is not publishing anything. On the other hand, the <code>/tf</code> is publishing a lot of messages: <pre><code>$ rostopic hz /tf\nsubscribed to [/tf]\naverage rate: 95.603\n        min: 0.009s max: 0.011s std dev: 0.00031s window: 9\n</code></pre> Approximately 100 Hz.</p>"},{"location":"tf_moveit/tf/#intermediate-assignment_1","title":"Intermediate assignment","text":"<p>Write a Python script that publishes three frames: <code>world</code>, <code>frame_1</code> and <code>frame_2</code>. The relations between them should be as follows:</p> <ul> <li><code>frame_1</code> is offset by 1m along the <code>Z</code> axis from <code>world</code></li> <li><code>frame_2</code> is offset by <code>sin(t)</code> along the <code>X</code> and <code>cos(t)</code> along the <code>Z</code> axis from <code>frame_1</code></li> </ul>"},{"location":"tf_moveit/urdf/","title":"Describing frame relations with URDF","text":""},{"location":"tf_moveit/urdf/#describing-frame-relations-with-urdf","title":"Describing frame relations with URDF","text":"<p>There is another approach to describe relations between different coordinate frames that is not writing Python scripts. That is writing something called the Unified Robot Description Format -- URDF. This is representation of the robot model written in an XML format. In this part of the workshop, we will learn how how it is structured, its syntax and how it is used in practice.</p>"},{"location":"tf_moveit/urdf/#simple-urdf-example","title":"Simple URDF example","text":"<p>Let's take the following URDF and examine what we see: <pre><code>&lt;robot name=\"simple\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n      &lt;link name=\"world\"/&gt;\n      &lt;link name=\"frame_1\"/&gt;\n      &lt;joint name=\"world_frame_1_joint\" type=\"fixed\"&gt;\n          &lt;parent link=\"world\"/&gt;\n          &lt;origin xyz=\"0.0 0.0 1.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n          &lt;child link=\"frame_1\"/&gt;\n      &lt;/joint&gt;\n&lt;/robot&gt;\n</code></pre></p> <p>In the above URDF we are defining two links: <code>world</code> and <code>frame_1</code> (the <code>&lt;link&gt;</code> tag). We then define a <code>&lt;joint&gt;</code> tag that describes their relation: <code>frame_1</code> is offset from <code>world</code> by 1m along the <code>Z</code> axis.</p> <p>With Python scripts it was easy -- we ran the script and we were able to observe these relations. Working with URDFs requires some extra steps.</p> <p>Copy the content of the code snippet above and store it into a file called <code>two_frames.urdf</code>. Then, load this file onto the parameter server as <code>/robot_description</code>: <pre><code>$ rosparam load two_frames.urdf /robot_description\n</code></pre></p> <p>Next, start something called the <code>robot_state_publisher</code> node (explanation follows): <pre><code>$ rosrun robot_state_publisher robot_state_publisher\n</code></pre></p> <p>Open another terminal (or if you're a pro user put the <code>robot_state_publisher</code> into the background) and check if the transformation is present on TF with <code>tf_echo</code>: <pre><code>$ rosrun tf tf_echo world frame_1\nAt time 0.000\n- Translation: [0.000, 0.000, 1.000]\n- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]\n            in RPY (radian) [0.000, -0.000, 0.000]\n            in RPY (degree) [0.000, -0.000, 0.000]\n</code></pre></p> <p>Question: From which topic do you expect this data to come from, <code>/tf</code> or <code>/tf_static</code>? Hint: observe the attributes of the <code>&lt;joint&gt;</code> tag.</p> <p>Terminate <code>tf_echo</code> and <code>robot_state_publisher</code> before continuing to the next section.</p>"},{"location":"tf_moveit/urdf/#robot-state-publisher-and-the-joint-state-publisher","title":"Robot state publisher and the joint state publisher","text":"<p>What we observed in the demonstration above is how URDFs work in combination with the <code>robot_state_publisher</code>. The above example was for a <code>static</code> coordinate frame relation. As you are very well aware, robot manipulators are many things, static is not one of them. To help with this, URDF supports different types of attributes for the joint <code>type</code>. However, if we describe it as something different than static, we need another piece of information. Let's explore this.</p> <p><pre><code>&lt;robot name=\"simple\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n      &lt;link name=\"world\"/&gt;\n      &lt;link name=\"frame_1\"/&gt;\n      &lt;link name=\"frame_2\"/&gt;\n      &lt;joint name=\"world_frame_1_joint\" type=\"fixed\"&gt;\n          &lt;parent link=\"world\"/&gt;\n          &lt;origin xyz=\"0.0 0.0 1.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n          &lt;child link=\"frame_1\"/&gt;\n      &lt;/joint&gt;\n      &lt;joint name=\"frame_1_frame_2_joint\" type=\"revolute\"&gt;\n          &lt;parent link=\"frame_1\"/&gt;\n          &lt;origin xyz=\"1.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n          &lt;axis xyz=\"0 0 1\" /&gt;\n          &lt;child link=\"frame_2\"/&gt;\n          &lt;limit lower=\"-3.14\" upper=\"3.14\" effort=\"1\" velocity=\"1\"/&gt;\n      &lt;/joint&gt;\n&lt;/robot&gt;\n</code></pre> Similarly to before, save this into a file and load it onto the parameter server as <code>/robot_description</code>.</p> <p>Once done, run the <code>robot_state_publisher</code> again.</p> <p>We can now observe what's available on TF. We first confirm that the relation between <code>world</code> and <code>frame_1</code> still works: <pre><code>$ rosrun tf tf_echo world frame_1\n</code></pre> Since we also defined <code>frame_2</code>, we also expect it to be visible, right? <pre><code>$ rosrun tf tf_echo frame_1 frame_2\nFailure at 1661194747.531982600\nException thrown:\"frame_2\" passed to lookupTransform argument source_frame does not exist.\nThe current list of frames is:\nFrame frame_1 exists with parent world.\n</code></pre> What's going on?</p> <p>As we explained before, if we use a joint of a type different than <code>static</code>, we need another piece of information. That is, the value of the joint motion status depending on the joint type. In our case we are dealing with <code>revolute</code> so we will need the angles for which the frame is turned around the joint.</p> <p>There is a handy tool available in ROS to help us with that. It's called the <code>joint_state_publisher</code>. This program will read the contents of the <code>/robot_description</code> parameter and publish \"some\" joint values. Let's try it out to see how it works. Open a new terminal and run the following command <pre><code>rosrun joint_state_publisher joint_state_publisher\n</code></pre></p> <p>In the other terminal use <code>tf_echo</code> to inspect the result: <pre><code>rosrun tf tf_echo frame_1 frame_2\nAt time 1661195066.017\n- Translation: [1.000, 0.000, 0.000]\n- Rotation: in Quaternion [0.000, 0.000, 0.000, 1.000]\n            in RPY (radian) [0.000, -0.000, 0.000]\n            in RPY (degree) [0.000, -0.000, 0.000]\n</code></pre></p> <p>Tadaaah! Before we move on, observe the content of the <code>/joint_states</code> topic: <pre><code>$ rostopic echo -n1 /joint_states\n</code></pre></p> <p>Note: The <code>-n1</code> flag of <code>rostopic echo</code> tells it to print only the first received message and then exit.</p> <p>We can now modify the value of the joint by terminating <code>joint_state_publisher</code> and run <code>joint_state_publisher_gui</code> instead: rosrun joint_state_publisher_gui joint_state_publisher_gui</p> <p></p> <p>Try moving the slider and observe the output of <code>tf_echo</code>.</p> <p>Before moving to the next part, simply terminate <code>tf_echo</code>. Leave <code>robot_state_publisher</code> and <code>joint_state_publisher_gui</code> running.</p>"},{"location":"tf_moveit/urdf/#visualizing-transforms-in-rviz","title":"Visualizing transforms in Rviz","text":"<p>By now you are probably tired of observing numbers changing and want to see some action. In this section, we will have a quick look at Rviz - a tool for visualizing robots in ROS.</p> <p>Let's give it a try by opening it: <pre><code>$ rviz\n</code></pre> You should be greeted by the following screen: </p> <p>You are probably disappointed that you still don't see anything interesting. Bear with us. From here, click on the <code>Add</code> button on the bottom right. A new window should appear:</p> <p> From the list select <code>TF</code> and click <code>Ok</code>.</p> <p>In the last step, we need to tell Rviz which of the frames is our origin. From the drop-down menu under <code>Global Options</code> select <code>world</code>:</p> <p></p> <p>If you did everything correctly, you should now be able to see the three coordinate frames we described in the URDF:</p> <p></p> <p>Try moving the slider from before (i.e. <code>joint_state_publisher_gui</code>) and observe how the frames react.</p>"},{"location":"tf_moveit/urdf/#assignment","title":"Assignment","text":"<p>In this assignment you will be creating two different Python scripts that will be used also during the practical assignment. It's in your interest to write them as good as possible so they help you later on.</p>"},{"location":"tf_moveit/urdf/#first-assignment-store-tf-data","title":"First assignment - store TF data","text":"<p>Write a Python script that stores the transformation between one frame (e.g. <code>world</code>) and another (e.g. <code>frame_2</code>) into a Pickle file (make up an extension, for example <code>.dat</code>).</p> <p>Note: Make sure that <code>robot_state_publisher</code> and <code>joint_satate_publisher</code> are running!</p> <p>For this assignment we prepared the following code snippet that you should complete: <pre><code>#! /usr/bin/env python\n\nimport rospy\nimport pickle\nimport os\nimport tf2_ros\n\nif __name__ == '__main__':\n\n    rospy.init_node('tf_saver')\n    rospy.loginfo(\"TF saver started!\")\n\n    tf_buffer = tf2_ros.Buffer()\n    tf_listener = tf2_ros.TransformListener(tf_buffer)\n\n    rospy.sleep(1)\n    stored_data = {}\n\n    ##### FILL IN THE APPROPRIATE FILENAME. HINT: USE `raw_input()`\n    file_name = \"\"\n    outfile = open(file_name,'wb')\n    saved_data = {}\n    #########################\n    ##### STUDENT WRITES ####\n    #########################\n\n\n    # Hint - Use the tf_buffer.lookup_transform() method to retrieve the transform.\n    # Example:\n    # transformation = tf_buffer.lookup_transform(from_frame, to_frame, rospy.Time(0))\n    # Note - from_frame and to_frame need to be defined!\n\n\n    #########################\n\n    pickle.dump(saved_data, outfile)\n    outfile.close()\n</code></pre></p>"},{"location":"tf_moveit/urdf/#second-assignment-load-data-to-tf","title":"Second assignment - load data to TF","text":"<p>Write a Python scrip that will read the Pickle file produced by the saver script and publish the transforms onto TF. We don't expect these frames to change in the future. You can therefore use the <code>StaticTransformBroadcaster()</code> class to publish them.</p> <p>For this assignment we prepared the following code snippet that you should complete:</p> <pre><code>#! /usr/bin/env python\n\nimport rospy\nimport pickle\n\nif __name__ == '__main__':\n\n    # Init the node\n    rospy.init_node('tf_loader')\n\n    ##### FILL IN THE APPROPRIATE FILENAME. HINT: USE `raw_input()`\n    file_name = \"\"\n\n    infile = open(file_name,'rb')\n    stored_poses = pickle.load(infile)\n    infile.close()\n\n    #########################\n    ##### STUDENT WRITES ####\n    #########################\n\n\n    #########################\n    rospy.spin()\n</code></pre>"}]}